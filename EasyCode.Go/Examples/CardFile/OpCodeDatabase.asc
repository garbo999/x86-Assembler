fld1=AAA
fld2=37
fld3=n/a
fld4=ASCII adjust after addition.
fld5=86

fld1=AAD
fld2=D5 0A
fld3=n/a
fld4=ASCII adjust AX before division.
fld5=86

fld1=AAM
fld2=D4 0A
fld3=n/a
fld4=ASCII adjust AX after multiply.
fld5=86

fld1=AAS
fld2=3F
fld3=n/a
fld4=ASCII adjust AL after subtraction.
fld5=86

fld1=ADC
fld2=14 ib
fld3=AL, imm8
fld4=Add two integers with carry.
fld5=86

fld1=ADC
fld2=15 iv
fld3=eAX, imm
fld4=Add two integers with carry.
fld5=86/386

fld1=ADC
fld2=81 /2 iv
fld3=r/m, imm
fld4=Add two integers with carry.
fld5=86/386

fld1=ADC
fld2=83 /2 ib
fld3=r/m, imm8
fld4=Add two integers with carry.
fld5=86/386

fld1=ADC
fld2=11 /r
fld3=r/m, r
fld4=Add two integers with carry.
fld5=86/386

fld1=ADC
fld2=80 /2 ib
fld3=r/m8, imm8
fld4=Add two integers with carry.
fld5=86

fld1=ADC
fld2=82 /2 ib
fld3=r/m8, imm8
fld4=Add two integers with carry.
fld5=86

fld1=ADC
fld2=10 /r
fld3=r/m8, r8
fld4=Add two integers with carry.
fld5=86

fld1=ADC
fld2=13 /r
fld3=r, r/m
fld4=Add two integers with carry.
fld5=86/386

fld1=ADC
fld2=12 /r
fld3=r8, r/m8
fld4=Add two integers with carry.
fld5=86

fld1=ADD
fld2=04 ib
fld3=AL, imm8
fld4=Add two integers.
fld5=86

fld1=ADD
fld2=05 iv
fld3=eAX, imm
fld4=Add two integers.
fld5=86/386

fld1=ADD
fld2=81 /0 iv
fld3=r/m, imm
fld4=Add two integers.
fld5=86/386

fld1=ADD
fld2=83 /0 ib
fld3=r/m, imm8
fld4=Add two integers.
fld5=86/386

fld1=ADD
fld2=01 /r
fld3=r/m, r
fld4=Add two integers.
fld5=86/386

fld1=ADD
fld2=80 /0 ib
fld3=r/m8, imm8
fld4=Add two integers.
fld5=86

fld1=ADD
fld2=82 /0 ib
fld3=r/m8, imm8
fld4=Add two integers.
fld5=86

fld1=ADD
fld2=00 /r
fld3=r/m8, r8
fld4=Add two integers.
fld5=86

fld1=ADD
fld2=03 /r
fld3=r, r/m
fld4=Add two integers.
fld5=86/386

fld1=ADD
fld2=02 /r
fld3=r8, r/m8
fld4=Add two integers.
fld5=86

fld1=ADDPD
fld2=66 0F 58 /r
fld3=xmm1, xmm2/m128
fld4=Add packed double-precision floats.
fld5=SSE2

fld1=ADDPS
fld2=0F 58 /r
fld3=xmm1, xmm2/m128
fld4=Add packed single-precision floats.
fld5=SSE

fld1=ADDSD
fld2=F2 0F 58 /r
fld3=xmm1, xmm2/m64
fld4=Add scalar double-precision floats.
fld5=

fld1=ADDSS
fld2=F3 0F 58 /r
fld3=xmm1, xmm2/m32
fld4=Add scalar single-precision floats.
fld5=SSE

fld1=ADDSUBPD
fld2=66 0F D0 /r
fld3=xmm1, xmm2/m128
fld4=Add/Sub packed double-precision floats.
fld5=SSE3

fld1=ADDSUBPS
fld2=F2 0F D0 /r
fld3=xmm1, xmm2/m128
fld4=Add/Sub packed single-precision floats.
fld5=SSE3

fld1=AND
fld2=24 ib
fld3=AL, imm8
fld4=Bitwise AND of two integers.
fld5=86

fld1=AND
fld2=25 iv
fld3=eAX, imm
fld4=Bitwise AND of two integers.
fld5=86/386

fld1=AND
fld2=81 /4 iv
fld3=r/m, imm
fld4=Bitwise AND of two integers.
fld5=86/386

fld1=AND
fld2=83 /4 ib
fld3=r/m, imm8
fld4=Bitwise AND of two integers.
fld5=86/386

fld1=AND
fld2=21 /r
fld3=r/m, r
fld4=Bitwise AND of two integers.
fld5=86/386

fld1=AND
fld2=80 /4 ib
fld3=r/m8, imm8
fld4=Bitwise AND of two integers.
fld5=86

fld1=AND
fld2=82 /4 ib
fld3=r/m8, imm8
fld4=Bitwise AND of two integers.
fld5=86

fld1=AND
fld2=20 /r
fld3=r/m8, r8
fld4=Bitwise AND of two integers.
fld5=86

fld1=AND
fld2=23 /r
fld3=r, r/m
fld4=Bitwise AND of two integers.
fld5=86/386

fld1=AND
fld2=22 /r
fld3=r8, r/m8
fld4=Bitwise AND of two integers.
fld5=86

fld1=ANDNPD
fld2=66 0F 55 /r
fld3=xmm1, xmm2/m128
fld4=Bitwise AND NOT of packed double-precision floats.
fld5=SSE2

fld1=ANDNPS
fld2=0F 55 /r
fld3=xmm1, xmm2/m128
fld4=Bitwise AND NOT of packed single-precision floats.
fld5=SSE

fld1=ANDPD
fld2=66 0F 54 /r
fld3=xmm1, xmm2/m128
fld4=Bitwise AND of packed double-precision floats.
fld5=SSE2

fld1=ANDPS
fld2=0F 54 /r
fld3=xmm1, xmm2/m128
fld4=Bitwise AND of packed single-precision floats.
fld5=SSE

fld1=ARPL
fld2=63 /r
fld3=r/m16, r16
fld4=Adjust RPL of field of segment selector.
fld5=286

fld1=BOUND
fld2=62 /r
fld3=r, m
fld4=Check array index against bounds.
fld5=186

fld1=BSF
fld2=0F BC /r
fld3=r, r/m
fld4=Scan for the least significant bit.
fld5=386

fld1=BSR
fld2=0F BD /r
fld3=r, r/m
fld4=Scan for the most significant bit.
fld5=386

fld1=BSWAP
fld2=0F C8
fld3=EAX
fld4=Reverses the byte order of 32-bit register.
fld5=486

fld1=BSWAP
fld2=0F CD
fld3=EBP
fld4=Reverses the byte order of 32-bit register.
fld5=486

fld1=BSWAP
fld2=0F CB
fld3=EBX
fld4=Reverses the byte order of 32-bit register.
fld5=486

fld1=BSWAP
fld2=0F C9
fld3=ECX
fld4=Reverses the byte order of 32-bit register.
fld5=486

fld1=BSWAP
fld2=0F CF
fld3=EDI
fld4=Reverses the byte order of 32-bit register.
fld5=486

fld1=BSWAP
fld2=0F CA
fld3=EDX
fld4=Reverses the byte order of 32-bit register.
fld5=486

fld1=BSWAP
fld2=0F CE
fld3=ESI
fld4=Reverses the byte order of 32-bit register.
fld5=486

fld1=BSWAP
fld2=0F CC
fld3=ESP
fld4=Reverses the byte order of 32-bit register.
fld5=486

fld1=BT
fld2=0F BA /4 ib
fld3=r/m, imm8
fld4=Extract a bit to CF.
fld5=386

fld1=BT
fld2=0F A3 /r
fld3=r/m, r
fld4=Extract a bit to CF.
fld5=386

fld1=BTC
fld2=0F BA /7 ib
fld3=r/m, imm8
fld4=Extract a bit to CF and complement it.
fld5=386

fld1=BTC
fld2=0F BB /r
fld3=r/m, r
fld4=Extract a bit to CF and complement it.
fld5=386

fld1=BTR
fld2=0F BA /6 ib
fld3=r/m, imm8
fld4=Extract a bit to CF and reset it.
fld5=386

fld1=BTR
fld2=0F B3
fld3=r/m, r
fld4=Extract a bit to CF and reset it.
fld5=386

fld1=BTS
fld2=0F BA /5 ib
fld3=r/m, imm8
fld4=Extract a bit to CF and set it.
fld5=386

fld1=BTS
fld2=0F AB
fld3=r/m, r
fld4=Extract a bit to CF and set it.
fld5=386

fld1=CALL
fld2=9A iv 1w
fld3=imm16:imm
fld4=A far, absolute call to a subroutine.
fld5=86

fld1=CALL
fld2=FF /3
fld3=m16:m
fld4=A far, absolute indirect call to a subroutine.
fld5=86

fld1=CALL
fld2=FF /2
fld3=r/m
fld4=A near, absolute indirect call to a subroutine.
fld5=86

fld1=CALL
fld2=E8 iv
fld3=rel
fld4=A near, relative call to a subroutine.
fld5=86

fld1=CBW/CWDE
fld2=98
fld3=n/a
fld4=Sign-extend AL into AX (or AX into EAX)
fld5=86/386

fld1=CLC
fld2=F8
fld3=n/a
fld4=Clear CF flag
fld5=86

fld1=CLD
fld2=FC
fld3=n/a
fld4=Clear DF flag
fld5=86

fld1=CLFLUSH
fld2=0F AE /mem|7
fld3=m8
fld4=Flushes cache line.
fld5=SSE2

fld1=CLI
fld2=FA
fld3=n/a
fld4=Clear the IF (disable interrupts).
fld5=86

fld1=CLTS
fld2=0F 06
fld3=n/a
fld4=Clear the task-switched (TS) flag in CR0.
fld5=286,PRIV

fld1=CMC
fld2=F5
fld3=n/a
fld4=Complement CF flag
fld5=86

fld1=CMOVA/CMOVNBE
fld2=0F 47 /r
fld3=r, r/m
fld4=Move if above (CF=0 and ZF=0)
fld5=P6

fld1=CMOVAE/CMOVNB//CMOVNC
fld2=0F 43 /r
fld3=r, r/m
fld4=Move if above or equal (CF=0)
fld5=P6

fld1=CMOVB/CMOVC/CMOVNAE
fld2=0F 42 /r
fld3=r, r/m
fld4=Move if below (CF=1)
fld5=P6

fld1=CMOVBE/CMOVNA
fld2=0F 46 /r
fld3=r, r/m
fld4=Move if below or equal (CF=1 or ZF=1)
fld5=P6

fld1=CMOVE/CMOVZ
fld2=0F 44 /r
fld3=r, r/m
fld4=Move if equal (ZF=1)
fld5=P6

fld1=CMOVG/CMOVNLE
fld2=0F 4F /r
fld3=r, r/m
fld4=Move if greater (ZF=0 and SF=OF)
fld5=P6

fld1=CMOVGE/CMOVNL
fld2=0F 4D /r
fld3=r, r/m
fld4=Move if greater or equal (SF=OF)
fld5=P6

fld1=CMOVL/CMOVNGE
fld2=0F 4C /r
fld3=r, r/m
fld4=Move if less (SF<>OF)
fld5=P6

fld1=CMOVLE/CMOVNG
fld2=0F 4E /r
fld3=r, r/m
fld4=Move if less or equal (ZF=1 or SF<>OF)
fld5=P6

fld1=CMOVNE/CMOVNZ
fld2=0F 45 /r
fld3=r, r/m
fld4=Move if not equal (ZF=0)
fld5=P6

fld1=CMOVNO
fld2=0F 41 /r
fld3=r, r/m
fld4=Move if not overflow (OF=0)
fld5=P6

fld1=CMOVNP/CMOVPO
fld2=0F 4B /r
fld3=r, r/m
fld4=Move if parity odd (PF=0)
fld5=P6

fld1=CMOVNS
fld2=0F 49 /r
fld3=r, r/m
fld4=Move if not sign (SF=0)
fld5=P6

fld1=CMOVO
fld2=0F 40 /r
fld3=r, r/m
fld4=Move if overflow (OF=1)
fld5=P6

fld1=CMOVP/CMOVPE
fld2=0F 4A /r
fld3=r, r/m
fld4=Move if parity even (PF=1)
fld5=P6

fld1=CMOVS
fld2=0F 48 /r
fld3=r, r/m
fld4=Move if sign (SF=1)
fld5=P6

fld1=CMP
fld2=3C ib
fld3=AL, imm8
fld4=Compare two integers.
fld5=86

fld1=CMP
fld2=3D iv
fld3=eAX, imm
fld4=Compare two integers.
fld5=86/386

fld1=CMP
fld2=81 /7 iv
fld3=r/m, imm
fld4=Compare two integers.
fld5=86/386

fld1=CMP
fld2=83 /7 ib
fld3=r/m16, imm8
fld4=Compare two integers.
fld5=86/386

fld1=CMP
fld2=39 /r
fld3=r/m, r
fld4=Compare two integers.
fld5=86/386

fld1=CMP
fld2=80 /7 ib
fld3=r/m8, imm8
fld4=Compare two integers.
fld5=86

fld1=CMP
fld2=82 /7 ib
fld3=r/m8, imm8
fld4=Compare two integers.
fld5=86

fld1=CMP
fld2=38 /r
fld3=r/m8, r8
fld4=Compare two integers.
fld5=86

fld1=CMP
fld2=3B /r
fld3=r, r/m
fld4=Compare two integers.
fld5=86/386

fld1=CMP
fld2=3A /r
fld3=r8, r/m8
fld4=Compare two integers.
fld5=86

fld1=CMPEQPD
fld2=66 0F C2 /r 00
fld3=xmm1, xmm2/m128
fld4=Compare packed double-precision floats for equality.
fld5=SSE2

fld1=CMPEQPS
fld2=0F C2 /r 00
fld3=xmm1, xmm2/m128
fld4=Compare packed single-precision floats for equality.
fld5=SSE

fld1=CMPEQSD
fld2=F2 0F C2 /r 00
fld3=xmm1, xmm2/m64
fld4=Compare scalar double-precision floats for equality.
fld5=SSE2

fld1=CMPEQSS
fld2=F3 0F C2 /r 00
fld3=xmm1, xmm2/m32
fld4=Compare scalar single-precision floats for equality.
fld5=SSE

fld1=CMPLEPD
fld2=66 0F C2 /r 02
fld3=xmm1, xmm2/m128
fld4=Compare packed double-precision floats for less-than-or-equal.
fld5=SSE2

fld1=CMPLEPS
fld2=0F C2 /r 02
fld3=xmm1, xmm2/m128
fld4=Compare packed single-precision floats for less-than-or-equal.
fld5=SSE

fld1=CMPLESD
fld2=F2 0F C2 /r 02
fld3=xmm1, xmm2/m64
fld4=Compare scalar double-precision floats for less-than-or-equal.
fld5=SSE2

fld1=CMPLESS
fld2=F3 0F C2 /r 02
fld3=xmm1, xmm2/m32
fld4=Compare scalar single-precision floats for less-than-or-equal.
fld5=SSE

fld1=CMPLTPD
fld2=66 0F C2 /r 01
fld3=xmm1, xmm2/m128
fld4=Compare packed double-precision floats for less-than.
fld5=SSE2

fld1=CMPLTPS
fld2=0F C2 /r 01
fld3=xmm1, xmm2/m128
fld4=Compare packed single-precision floats for less-than.
fld5=SSE

fld1=CMPLTSD
fld2=F2 0F C2 /r 01
fld3=xmm1, xmm2/m64
fld4=Compare scalar double-precision floats for less-than.
fld5=SSE2

fld1=CMPLTSS
fld2=F3 0F C2 /r 01
fld3=xmm1, xmm2/m32
fld4=Compare scalar single-precision floats for less-than.
fld5=SSE

fld1=CMPNEQPD
fld2=66 0F C2 /r 04
fld3=xmm1, xmm2/m128
fld4=Compare packed double-precision floats for not-equal.
fld5=SSE2

fld1=CMPNEQPS
fld2=0F C2 /r 04
fld3=xmm1, xmm2/m128
fld4=Compare packed single-precision floats for not-equal.
fld5=SSE

fld1=CMPNEQSD
fld2=F2 0F C2 /r 04
fld3=xmm1, xmm2/m64
fld4=Compare scalar double-precision floats for not-equal.
fld5=SSE2

fld1=CMPNEQSS
fld2=F3 0F C2 /r 04
fld3=xmm1, xmm2/m32
fld4=Compare scalar single-precision floats for not-equal.
fld5=SSE

fld1=CMPNLEPD
fld2=66 0F C2 /r 06
fld3=xmm1, xmm2/m128
fld4=Compare packed double-precision floats for not-greater-than.
fld5=SSE2

fld1=CMPNLEPS
fld2=0F C2 /r 06
fld3=xmm1, xmm2/m128
fld4=Compare packed single-precision floats for not-greater-than.
fld5=SSE

fld1=CMPNLESD
fld2=F2 0F C2 /r 06
fld3=xmm1, xmm2/m64
fld4=Compare scalar double-precision floats for not-greater-than.
fld5=SSE2

fld1=CMPNLESS
fld2=F3 0F C2 /r 06
fld3=xmm1, xmm2/m32
fld4=Compare scalar single-precision floats for not-greater-than.
fld5=SSE

fld1=CMPNLTPD
fld2=66 0F C2 /r 05
fld3=xmm1, xmm2/m128
fld4=Compare packed double-precision floats for not-less-than.
fld5=SSE2

fld1=CMPNLTPS
fld2=0F C2 /r 05
fld3=xmm1, xmm2/m128
fld4=Compare packed single-precision floats for not-less-than.
fld5=SSE

fld1=CMPNLTSD
fld2=F2 0F C2 /r 05
fld3=xmm1, xmm2/m64
fld4=Compare scalar double-precision floats for not-less-than.
fld5=SSE2

fld1=CMPNLTSS
fld2=F3 0F C2 /r 05
fld3=xmm1, xmm2/m32
fld4=Compare scalar single-precision floats for not-less-than.
fld5=SSE

fld1=CMPORDPD
fld2=66 0F C2 /r 07
fld3=xmm1, xmm2/m128
fld4=Compare packed double-precision floats for being ordered.
fld5=SSE2

fld1=CMPORDPS
fld2=0F C2 /r 07
fld3=xmm1, xmm2/m128
fld4=Compare packed single-precision floats for being ordered.
fld5=SSE

fld1=CMPORDSD
fld2=F2 0F C2 /r 07
fld3=xmm1, xmm2/m64
fld4=Compare scalar double-precision floats for being ordered.
fld5=SSE2

fld1=CMPORDSS
fld2=F3 0F C2 /r 07
fld3=xmm1, xmm2/m32
fld4=Compare scalar single-precision floats for being ordered.
fld5=SSE

fld1=CMPPD
fld2=66 0F C2 /r ib
fld3=xmm1, xmm2/m64, imm8
fld4=Compare packed double-precision floats.
fld5=SSE2

fld1=CMPPS
fld2=0F C2 /r ib
fld3=xmm1, xmm2/m32, imm8
fld4=Compare packed single-precision floats.
fld5=SSE

fld1=CMPSB
fld2=A6
fld3=n/a
fld4=Compare string bytes.
fld5=86

fld1=CMPSD
fld2=F2 0F C2 /r ib
fld3=xmm1, xmm2/m64, imm8
fld4=Compare scalar double-precision floats.
fld5=SSE2

fld1=CMPSS
fld2=F3 0F C2 /r ib
fld3=xmm1, xmm2/m32, imm8
fld4=Compare scalar single-precision floats.
fld5=SSE

fld1=CMPSW/CMPSD
fld2=A7
fld3=n/a
fld4=Compare string words/dwords.
fld5=86/386

fld1=CMPUNORDPD
fld2=66 0F C2 /r 03
fld3=xmm1, xmm2/m128
fld4=Compare packed double-precision floats for being ordered.
fld5=SSE2

fld1=CMPUNORDPS
fld2=0F C2 /r 03
fld3=xmm1, xmm2/m128
fld4=Compare packed single-precision floats for being unordered.
fld5=SSE

fld1=CMPUNORDSD
fld2=F2 0F C2 /r 03
fld3=xmm1, xmm2/m64
fld4=Compare scalar double-precision floats for being unordered.
fld5=SSE2

fld1=CMPUNORDSS
fld2=F3 0F C2 /r 03
fld3=xmm1, xmm2/m32
fld4=Compare scalar single-precision floats for being unordered.
fld5=SSE

fld1=CMPXCHG
fld2=0F B1/r
fld3=r/m, r
fld4=Compare and exchange.
fld5=P5

fld1=CMPXCHG
fld2=0F B0/r
fld3=r/m8, r8
fld4=Compare and exchange.
fld5=P5

fld1=CMPXCHG486
fld2=0F A7 /r
fld3=r/m, r
fld4=Undocumented alias to CMPXCHG on some old 486s.
fld5=486, UNDOC

fld1=CMPXCHG486
fld2=0F A6 /r
fld3=r/m8, r8
fld4=Undocumented alias to CMPXCHG on some old 486s.
fld5=486, UNDOC

fld1=CMPXCHG8B
fld2=0F C7 /mem|1
fld3=m64
fld4=Compare and exchange 8 bytes.
fld5=P5

fld1=COMISD
fld2=66 0F 2F /r
fld3=xmm1, xmm2/m64
fld4=Compare scalar ordered double-precision floats.
fld5=SSE2

fld1=COMISS
fld2=0F 2F /r
fld3=xmm1, xmm2/m32
fld4=Compare scalar ordered single-precision floats.
fld5=SSE

fld1=CPUID
fld2=0F A2
fld3=n/a
fld4=CPU identification.
fld5=P5

fld1=CVTDQ2PD
fld2=F3 0F E6 /r
fld3=xmm1, xmm2/m64
fld4=Convert two packed signed dwords to two packed double-precision floats.
fld5=SSE2

fld1=CVTDQ2PS
fld2=0F 5B /r
fld3=xmm1, xmm2/m128
fld4=Convert four packed signed dwords to four packed single-precision floats.
fld5=SSE2

fld1=CVTPD2DQ
fld2=F2 0F E6
fld3=xmm1, xmm2/m128
fld4=Convert two packed double-precision floats to two packed signed dwords.
fld5=SSE2

fld1=CVTPD2PI
fld2=66 0F 2D /r
fld3=mm, xmm/m128
fld4=Convert two packed double-precision floats to two packed signed dwords.
fld5=SSE2

fld1=CVTPD2PS
fld2=66 0F 5A /r
fld3=xmm1, xmm2/m128
fld4=Convert two packed double-precision floats to two packed single-precision floats.
fld5=SSE2

fld1=CVTPI2PD
fld2=66 0F 2A /r
fld3=xmm, mm/m64
fld4=Convert two packed signed dwords to two packed double-precision floats.
fld5=sse2

fld1=CVTPI2PS
fld2=0F 2A /r
fld3=xmm, mm/m64
fld4=Convert two signed dwords to two single-precision floats.
fld5=SSE

fld1=CVTPS2DQ
fld2=66 0F 5B /r
fld3=xmm1, xmm2/m128
fld4=Convert four packed single-precision floats to four packed signed dwords.
fld5=sse2

fld1=CVTPS2PD
fld2=0F 5A /r
fld3=xmm1, xmm2/m64
fld4=Convert two packed single-precision floats to two packed double-precision floats.
fld5=SSE2

fld1=CVTPS2PI
fld2=0F 2D /r
fld3=mm, xmm/m64
fld4=Convert two packed single-precision floats to two packed signed dwords.
fld5=SSE

fld1=CVTSD2SI
fld2=F2 0F 2D /r
fld3=r32, xmm/m64
fld4=Convert one double-precision float to one signed dword.
fld5=SSE2

fld1=CVTSD2SS
fld2=F2 0F 5A /r
fld3=xmm1, xmm2/m64
fld4=Convert one double-precision float to one single-precision float.
fld5=SSE

fld1=CVTSI2SD
fld2=F2 0F 2A /r
fld3=xmm, r/m32
fld4=Convert one signed dword to one double-precision float.
fld5=SSE2

fld1=CVTSI2SS
fld2=F3 0F 2A /r
fld3=xmm, r/m32
fld4=Convert one signed dword to one single-precision float.
fld5=SSE

fld1=CVTSS2SD
fld2=F3 0F 5A /r
fld3=xmm1, xmm2/m32
fld4=Convert one single-precision float to one double-precision float.
fld5=SSE2

fld1=CVTSS2SI
fld2=F3 0F 2D /r
fld3=r32, xmm/m32
fld4=Convert one single-precision float to one signed dword.
fld5=SSE

fld1=CVTTPD2DQ
fld2=66 0F E6
fld3=xmm1, xmm2/m128
fld4=Truncate two packed double-precision floats to two packed signed dwords.
fld5=SSE2

fld1=CVTTPD2PI
fld2=66 0F 2C /r
fld3=mm, xmm/m128
fld4=Truncate two packer double-precision floats to two packed signed dwords.
fld5=SSE2

fld1=CVTTPS2DQ
fld2=F3 0F 5B /r
fld3=xmm1, xmm2/m128
fld4=Truncate four packed single-precision floats to four packed signed dwords.
fld5=SSE2

fld1=CVTTPS2PI
fld2=0F 2C /r
fld3=mm, xmm/m64
fld4=Truncate two packed single-precision floats to two signed packed dwords.
fld5=SSE

fld1=CVTTSD2SI
fld2=F2 0F 2C /r
fld3=r32, xmm/m64
fld4=Truncate one double-precision float to one signed dword.
fld5=SSE2

fld1=CVTTSS2SI
fld2=F3 0F 2C /r
fld3=r32, xmm/m32
fld4=Convert one single-precision float to one signed dword.
fld5=SSE

fld1=CWD/CDQ
fld2=99
fld3=n/a
fld4=Sign-extend AX into DX:AX (or EAX into EDX:EAX).
fld5=86/386

fld1=DAA
fld2=27
fld3=n/a
fld4=Decimal adjust AL after addition
fld5=86

fld1=DAS
fld2=2F
fld3=n/a
fld4=Decimal adjust AL after subtraction
fld5=86

fld1=DEC
fld2=48
fld3=eAX
fld4=Decrement integer by 1
fld5=86/386

fld1=DEC
fld2=4D
fld3=eBP
fld4=Decrement integer by 1
fld5=86/386

fld1=DEC
fld2=4B
fld3=eBX
fld4=Decrement integer by 1
fld5=86/386

fld1=DEC
fld2=49
fld3=eCX
fld4=Decrement integer by 1
fld5=86/386

fld1=DEC
fld2=4F
fld3=eDI
fld4=Decrement integer by 1
fld5=86/386

fld1=DEC
fld2=4A
fld3=eDX
fld4=Decrement integer by 1
fld5=86/386

fld1=DEC
fld2=4E
fld3=eSI
fld4=Decrement integer by 1
fld5=86/386

fld1=DEC
fld2=4C
fld3=eSP
fld4=Decrement integer by 1
fld5=86/386

fld1=DEC
fld2=FE /1
fld3=r/m8
fld4=Decrement integer by 1
fld5=86

fld1=DEC
fld2=FF /1
fld3=r/m
fld4=Decrement integer by 1
fld5=86/386

fld1=DIV
fld2=F7 /6
fld3=r/m
fld4=Unsigned divide eDX:eAX by the operand.
fld5=86/386

fld1=DIV
fld2=F6 /6
fld3=r/m8
fld4=Unsigned divide AX by the operand.
fld5=86

fld1=DIVPD
fld2=66 0F 5E /r
fld3=xmm1, xmm2/m128
fld4=Divide packed double-precision floats.
fld5=SSE2

fld1=DIVPS
fld2=0F 5E /r
fld3=xmm1, xmm2/m128
fld4=Divide packed single-precision floats.
fld5=SSE

fld1=DIVSD
fld2=F2 0F 5E /r
fld3=xmm1, xmm2/m64
fld4=Divide scalar double-precision floats.
fld5=SSE2

fld1=DIVSS
fld2=F3 0F 5E /r
fld3=xmm1, xmm2/m32
fld4=Divide scalar single-precision floats.
fld5=SSE

fld1=EMMS
fld2=0F 77
fld3=n/a
fld4=Empty MMX state.
fld5=MMX

fld1=ENTER
fld2=C8 iw ib
fld3=imm16, imm8
fld4=Create a stack frame for a procedure or subroutine.
fld5=186

fld1=F2XM1
fld2=D9 F0
fld3=n/a
fld4=Compute 2 to the power of ST(0) – 1.
fld5=86,FPU

fld1=FABS
fld2=D9 E1
fld3=n/a
fld4=Absolute value of ST(0).
fld5=86,FPU

fld1=FADD
fld2=D8 /0
fld3=m32
fld4=Add single-precision float to ST(0).
fld5=86,FPU

fld1=FADD
fld2=DC /0
fld3=m64
fld4=Add double-precision float to ST(0).
fld5=86,FPU

fld1=FADD
fld2=D8 C0+i
fld3=ST(0), ST(i)
fld4=Add ST(i) to ST(0).
fld5=86,FPU

fld1=FADD
fld2=DC C0+i
fld3=ST(i), ST(0)
fld4=Add ST(0) to ST(i).
fld5=86,FPU

fld1=FADDP
fld2=DE C0+i
fld3=ST(i), ST(0)
fld4=Add ST(0) to ST(i) and pop the FPU stack.
fld5=86,FPU

fld1=FBLD
fld2=DF /4
fld3=m80
fld4=Push BCD value onto the FPU stack.
fld5=86,FPU

fld1=FBSTP
fld2=DF /6
fld3=m80
fld4=Store ST(0) as BCD value and pop FPU stack.
fld5=86,FPU

fld1=FCHS
fld2=D9 E0
fld3=n/a
fld4=Change sign of ST(0).
fld5=86,FPU

fld1=FCLEX
fld2=9B DB E2
fld3=n/a
fld4=Clear FPU exception flags and wait.
fld5=86,FPU

fld1=FCMOVB
fld2=DA C0+i
fld3=ST(0), ST(i)
fld4=FPU move if below (CF=1)
fld5=86,FPU

fld1=FCMOVBE
fld2=DA D0+i
fld3=ST(0), ST(i)
fld4=FPU move if below or equal (CF=1 or ZF=1)
fld5=86,FPU

fld1=FCMOVE
fld2=DA C8+i
fld3=ST(0), ST(i)
fld4=FPU move if equal (ZF=1)
fld5=86,FPU

fld1=FCMOVNB
fld2=DB C0+i
fld3=ST(0), ST(i)
fld4=FPU move if not below (CF=0)
fld5=86,FPU

fld1=FCMOVNBE
fld2=DB D0+i
fld3=ST(0), ST(i)
fld4=FPU move if not below or equal (CF=0 and ZF=0)
fld5=86,FPU

fld1=FCMOVNE
fld2=DB C8+i
fld3=ST(0), ST(i)
fld4=FPU move if not equal (ZF=0)
fld5=86,FPU

fld1=FCMOVNU
fld2=DB D8+i
fld3=ST(0), ST(i)
fld4=FPU move if not unordered (PF=0)
fld5=86,FPU

fld1=FCMOVU
fld2=DA D8+i
fld3=ST(0), ST(i)
fld4=FPU move if unordered (PF=1)
fld5=86,FPU

fld1=FCOM
fld2=D8 /2
fld3=m32
fld4=Compare ST(0) with single-precision float.
fld5=86,FPU

fld1=FCOM
fld2=DC /2
fld3=m64
fld4=Compare ST(0) with double-precision float.
fld5=86,FPU

fld1=FCOM
fld2=D8 D0+i
fld3=ST(i)
fld4=Compare ST(0) ST(i).
fld5=86,FPU

fld1=FCOM2
fld2=DC D0+i
fld3=ST(i)
fld4=Undocumented alias to FCOM ST(i).
fld5=86,FPU,UNDOC

fld1=FCOMI
fld2=DB F0+i
fld3=ST(0), ST(i)
fld4=Compare ST(0) with ST(i) and set CPU flags.
fld5=86,FPU

fld1=FCOMIP
fld2=DF F0+i
fld3=ST(0), ST(i)
fld4=Compare ST(0) with ST(i), set CPU flags and pop FPU stack.
fld5=86,FPU

fld1=FCOMP
fld2=D8 /3
fld3=m32
fld4=Compare ST(0) with single-precision float and pop FPU stack.
fld5=86,FPU

fld1=FCOMP
fld2=DC /3
fld3=m64
fld4=Compare ST(0) with double-precision float and pop FPU stack.
fld5=86,FPU

fld1=FCOMP
fld2=D8 D8+i
fld3=ST(i)
fld4=Compare ST(0) with ST(i) and pop FPU stack.
fld5=86,FPU

fld1=FCOMP3
fld2=DC D8+i
fld3=ST(i)
fld4=Undocumented alias to FCOMP ST(i).
fld5=86,FPU,UNDOC

fld1=FCOMP5
fld2=DE D0+i
fld3=ST(i)
fld4=Undocumented alias to FCOMP ST(i).
fld5=86,FPU,UNDOC

fld1=FCOMPP
fld2=DE D9
fld3=n/a
fld4=Compare ST(0) with ST(1) and pop FPU stack twice.
fld5=86,FPU

fld1=FCOS
fld2=D9 FF
fld3=n/a
fld4=Replace ST(0) with its cosine
fld5=386,FPU

fld1=FDECSTP
fld2=D9 F6
fld3=n/a
fld4=Decrement FPU stack pointer.
fld5=86,FPU

fld1=FDISI
fld2=9B DB E1
fld3=n/a
fld4=Disable FPU interrupts and wait.
fld5=86,FPU

fld1=FDIV
fld2=D8 /6
fld3=m32
fld4=Divide ST(0) by single-precision float.
fld5=86,FPU

fld1=FDIV
fld2=DC /6
fld3=m64
fld4=Divide ST(0) by double-precision float.
fld5=86,FPU

fld1=FDIV
fld2=D8 F0+i
fld3=ST(0), ST(i)
fld4=Divide ST(0) by ST(i).
fld5=86,FPU

fld1=FDIV
fld2=DC F8+i
fld3=ST(i), ST(0)
fld4=Divide ST(i) by ST(0).
fld5=86,FPU

fld1=FDIVP
fld2=DE F8+i
fld3=ST(i), ST(0)
fld4=Divide ST(i) by ST(0) and pop the FPU stack
fld5=86,FPU

fld1=FDIVR
fld2=D8 /7
fld3=m32
fld4=Divide single-precision float.
fld5=86,FPU

fld1=FDIVR
fld2=DC /7
fld3=m64
fld4=Divide double-precision float.
fld5=86,FPU

fld1=FDIVR
fld2=D8 F8+i
fld3=ST(0), ST(i)
fld4=Divide ST(i) by ST(0).
fld5=86,FPU

fld1=FDIVR
fld2=DC F0+i
fld3=ST(i), ST(0)
fld4=Divide ST(0) by ST(i).
fld5=86,FPU

fld1=FDIVRP
fld2=DE F0+i
fld3=ST(i), ST(0)
fld4=Divide ST(0) by ST(i) and pop the FPU stack.
fld5=86,FPU

fld1=FEMMS
fld2=0F 0E
fld3=n/a
fld4=Fast empty MMX state.
fld5=3DNOW

fld1=FENI
fld2=9B DB E0
fld3=n/a
fld4=Enable FPU interrupts and wait.
fld5=86,FPU

fld1=FFREE
fld2=DD C0+i
fld3=ST(i)
fld4=Mark ST(i) as being empty.
fld5=86,FPU

fld1=FFREEP
fld2=DF C0+i
fld3=ST(i)
fld4=Mark ST(i) as being empty and pop FPU stack.
fld5=286,FPU,UNDOC

fld1=FIADD
fld2=DE /0
fld3=m16
fld4=Add integer word to ST(0).
fld5=86,FPU

fld1=FIADD
fld2=DA /0
fld3=m32
fld4=Add integer dword to ST(0).
fld5=86,FPU

fld1=FICOM
fld2=DE /2
fld3=m16
fld4=Compare ST(0) with word.
fld5=86,FPU

fld1=FICOM
fld2=DA /2
fld3=m32
fld4=Compare ST(0) with dword.
fld5=86,FPU

fld1=FICOMP
fld2=DE /3
fld3=m16
fld4=Compare ST(0) with word and pop FPU stack.
fld5=86,FPU

fld1=FICOMP
fld2=DA /3
fld3=m32
fld4=Compare ST(0) with dword and pop FPU stack.
fld5=86,FPU

fld1=FIDIV
fld2=DE /6
fld3=m16
fld4=Divide ST(0) with word.
fld5=86,FPU

fld1=FIDIV
fld2=DA /6
fld3=m32
fld4=Divide ST(0) with dword.
fld5=86,FPU

fld1=FIDIVR
fld2=DE /7
fld3=m16
fld4=Divide word by ST(0).
fld5=86,FPU

fld1=FIDIVR
fld2=DA /7
fld3=m32
fld4=Divide dword by ST(0).
fld5=86,FPU

fld1=FILD
fld2=DF /0
fld3=m16
fld4=Push word onto the FPU stack.
fld5=86,FPU

fld1=FILD
fld2=DB /0
fld3=m32
fld4=Push dword onto the FPU stack.
fld5=86,FPU

fld1=FILD
fld2=DF /5
fld3=m64
fld4=Push qword onto the FPU stack.
fld5=86,FPU

fld1=FIMUL
fld2=DE /1
fld3=m16
fld4=Multiply ST(0) by word.
fld5=86,FPU

fld1=FIMUL
fld2=DA /1
fld3=m32
fld4=Multiply ST(0) by dword.
fld5=86,FPU

fld1=FINCSTP
fld2=D9 F7
fld3=n/a
fld4=Increment FPU stack pointer.
fld5=86,FPU

fld1=FINIT
fld2=9B DB E3
fld3=n/a
fld4=Initialize FPU and wait.
fld5=86,FPU

fld1=FIST
fld2=DF /2
fld3=m16
fld4=Store ST(0) as word.
fld5=86,FPU

fld1=FIST
fld2=DB /2
fld3=m32
fld4=Store ST(0) as dword.
fld5=86,FPU

fld1=FISTP
fld2=DF /3
fld3=m16
fld4=Store ST(0) as word and pop FPU stack.
fld5=86,FPU

fld1=FISTP
fld2=DB /3
fld3=m32
fld4=Store ST(0) as dword and pop FPU stack.
fld5=86,FPU

fld1=FISTP
fld2=DF /7
fld3=m64
fld4=Store ST(0) as qword and pop FPU stack.
fld5=86,FPU

fld1=FISTTP
fld2=DF /1
fld3=m16
fld4=Store ST(0) as word with truncation and pop FPU stack.
fld5=SSE3

fld1=FISTTP
fld2=DB /1
fld3=m32
fld4=Store ST(0) as dword with truncation and pop FPU stack.
fld5=SSE3

fld1=FISTTP
fld2=DD /1
fld3=m64
fld4=Store ST(0) as qword with truncation and pop FPU stack.
fld5=SSE3

fld1=FISUB
fld2=DE /4
fld3=m16
fld4=Subtract word from ST(0).
fld5=86,FPU

fld1=FISUB
fld2=DA /4
fld3=m32
fld4=Subtract dwordt from ST(0).
fld5=86,FPU

fld1=FISUBR
fld2=DE /5
fld3=m16
fld4=Subtract ST(0) from word.
fld5=86,FPU

fld1=FISUBR
fld2=DA /5
fld3=m32
fld4=Subtract ST(0) from dword.
fld5=86,FPU

fld1=FLD
fld2=D9 /0
fld3=m32
fld4=Push single-precision float onto the FPU stack.
fld5=86,FPU

fld1=FLD
fld2=DD /0
fld3=m64
fld4=Push double-precision float onto the FPU stack.
fld5=86,FPU

fld1=FLD
fld2=DB /5
fld3=m80
fld4=Push 80-bit float onto the FPU stack.
fld5=86,FPU

fld1=FLD
fld2=D9 C0+i
fld3=ST(i)
fld4=Push ST(i) onto the FPU stack.
fld5=86,FPU

fld1=FLD1
fld2=D9 E8
fld3=n/a
fld4=Push +1.0 onto the FPU stack.
fld5=86,FPU

fld1=FLDCW
fld2=D9 /5
fld3=m16
fld4=Load source into FPU control word.
fld5=86,FPU

fld1=FLDENV
fld2=D9 /4
fld3=mem
fld4=Load FPU environment.
fld5=86,FPU

fld1=FLDL2E
fld2=D9 EA
fld3=n/a
fld4=Push log2(e) onto the FPU stack.
fld5=86,FPU

fld1=FLDLG2
fld2=D9 EC
fld3=n/a
fld4=Push log10(2) onto the FPU stack.
fld5=86,FPU

fld1=FLDLN2
fld2=D9 ED
fld3=n/a
fld4=Push ln(2) onto the FPU stack.
fld5=86,FPU

fld1=FLDPI
fld2=D9 EB
fld3=n/a
fld4=Push pi onto the FPU stack.
fld5=86,FPU

fld1=FLDZ
fld2=D9 EE
fld3=n/a
fld4=Push +0.0 onto the FPU stack.
fld5=86,FPU

fld1=FMUL
fld2=D8 /1
fld3=m32
fld4=Multiply ST(0) by single-precision float.
fld5=86,FPU

fld1=FMUL
fld2=DC /1
fld3=m64
fld4=Multiply ST(0) by double-precision float.
fld5=86,FPU

fld1=FMUL
fld2=D8 C8+i
fld3=ST(0), ST(i)
fld4=Multiply ST(0) by ST(i).
fld5=86,FPU

fld1=FMUL
fld2=DC C8+i
fld3=ST(i), ST(0)
fld4=Multiply ST(i) by ST(0).
fld5=86,FPU

fld1=FMULP
fld2=DE C8+i
fld3=ST(i), ST(0)
fld4=Multiply ST(i) by ST(0) and pop the FPU stack.
fld5=86,FPU

fld1=FNCLEX
fld2=DB E2
fld3=n/a
fld4=Clear FPU exception flags.
fld5=86,FPU

fld1=FNDISI
fld2=DB E1
fld3=n/a
fld4=Disable FPU interrupts.
fld5=86,FPU

fld1=FNENI
fld2=DB E0
fld3=n/a
fld4=Enable FPU interrupts.
fld5=86,FPU

fld1=FNINIT
fld2=DB E3
fld3=n/a
fld4=Initialize FPU.
fld5=86,FPU

fld1=FNOP
fld2=D9 D0
fld3=n/a
fld4=FPU no operation is performed.
fld5=86,FPU

fld1=FNSAVE
fld2=DD /6
fld3=mem
fld4=Save FPU state.
fld5=86,FPU

fld1=FNSTCW
fld2=D9 /7
fld3=m16
fld4=Store FPU control word in memory.
fld5=86,FPU

fld1=FNSTDW
fld2=D9 /7
fld3=AX
fld4=Store device word into AX (only on i387SL Mobile).
fld5=386,FPU,UNDOC

fld1=FNSTENV
fld2=D9 /6
fld3=mem
fld4=Store FPU environment.
fld5=86,FPU

fld1=FNSTSG
fld2=DF E2
fld3=AX
fld4=Store signature word into AX (only on i387SL Mobile).
fld5=386,FPU,UNDOC

fld1=FNSTSW
fld2=DF E0
fld3=AX
fld4=Store FPU status word into AX.
fld5=286,FPU

fld1=FNSTSW
fld2=DD /7
fld3=m16
fld4=Store FPU status word into memory.
fld5=86,FPU

fld1=FPATAN
fld2=D9 F3
fld3=n/a
fld4=Put arctan(ST(1)/ST(0)) to ST(1) and pop the FPU stack.
fld5=86,FPU

fld1=FPREM
fld2=D9 F8
fld3=n/a
fld4=Partial remainder rounded towards 0.
fld5=86,FPU

fld1=FPREM1
fld2=D9 F5
fld3=n/a
fld4=Partial remainder rounded to the nearest integer.
fld5=386,FPU

fld1=FPTAN
fld2=D9 F2
fld3=n/a
fld4=Put tan(ST(0)) to ST(0) and push 1 onto FPU stack.
fld5=86,FPU

fld1=FRICHOP
fld2=DD FC
fld3=n/a
fld4=Round ST(0) towards zero (only on Cyrix and 486s).
fld5=486,FPU,CYRIX

fld1=FRINEAR
fld2=DF FC
fld3=n/a
fld4=Round ST(0) to nearest integer (only on Cyrix and 486s).
fld5=486,FPU,CYRIX

fld1=FRINT2
fld2=DB FC
fld3=n/a
fld4=Round ST(0) to integer (only on Cyrix and 486s).
fld5=486,FPU,CYRIX

fld1=FRNDINT
fld2=D9 FC
fld3=n/a
fld4=Round ST(0) to an integer.
fld5=86,FPU

fld1=FRSTOR
fld2=DD /4
fld3=mem
fld4=Restore FPU state.
fld5=86,FPU

fld1=FSAVE
fld2=9B DD /6
fld3=mem
fld4=Save FPU state and wait.
fld5=86,FPU

fld1=FSCALE
fld2=D9 FD
fld3=n/a
fld4=Scale ST(0) by ST(1).
fld5=86,FPU

fld1=FSETPM
fld2=DB E4
fld3=n/a
fld4=Set protected mode (only on 286s).
fld5=286,FPU,PRIV

fld1=FSIN
fld2=D9 FE
fld3=n/a
fld4=Replace ST(0) with its sine.
fld5=386,FPU

fld1=FSINCOS
fld2=D9 FB
fld3=n/a
fld4=Compute the sine and cosine of ST(0).
fld5=386,FPU

fld1=FSQRT
fld2=D9 FA
fld3=n/a
fld4=Replace ST(0) with its square root.
fld5=86,FPU

fld1=FST
fld2=D9 /2
fld3=m32
fld4=Copy ST(0) to single-precision float.
fld5=86,FPU

fld1=FST
fld2=DD /2
fld3=m64
fld4=Copy ST(0) to double-precision float.
fld5=86,FPU

fld1=FST
fld2=DD D0+i
fld3=ST(i)
fld4=Copy ST(0) to ST(i)
fld5=86,FPU

fld1=FSTP
fld2=D9 /3
fld3=m32
fld4=Copy ST(0) to single-precision float and pop FPU stack
fld5=86,FPU

fld1=FSTP
fld2=DD /3
fld3=m64
fld4=Copy ST(0) to double-precision float and pop FPU stack
fld5=86,FPU

fld1=FSTP
fld2=DB /7
fld3=m80
fld4=Copy ST(0) to 80-bit float and pop FPU stack
fld5=86,FPU

fld1=FSTP
fld2=DD D8+i
fld3=ST(i)
fld4=Copy ST(0) to ST(i) and pop FPU stack
fld5=86,FPU

fld1=FSTP1
fld2=D9 D8+i
fld3=ST(i)
fld4=Undocumented alias to FSTP ST(i)
fld5=86,FPU,UNDOC

fld1=FSTP8
fld2=DF D0+i
fld3=ST(i)
fld4=Undocumented alias to FSTP ST(i)
fld5=86,FPU,UNDOC

fld1=FSTP9
fld2=DF D8+i
fld3=ST(i)
fld4=Undocumented alias to FSTP ST(i)
fld5=86,FPU,UNDOC

fld1=FSTSW
fld2=9B DF E0
fld3=AX
fld4=Store FPU status word into AX and wait.
fld5=286,FPU

fld1=FSTSW
fld2=9B DD /7
fld3=mem
fld4=Store FPU status word into memory and wait.
fld5=86,FPU

fld1=FSUB
fld2=D8 /4
fld3=m32
fld4=Subtract single-precision float from ST(0).
fld5=86,FPU

fld1=FSUB
fld2=DC /4
fld3=m64
fld4=Subtract double-precision float from ST(0).
fld5=86,FPU

fld1=FSUB
fld2=D8 E0+i
fld3=ST(0), ST(i)
fld4=Subtract ST(i) from ST(0).
fld5=86,FPU

fld1=FSUB
fld2=DC E8+i
fld3=ST(i), ST(0)
fld4=Subtract ST(0) from ST(i).
fld5=86,FPU

fld1=FSUBP
fld2=DE E8+i
fld3=ST(i), ST(0)
fld4=Subtract ST(0) from ST(i) and pop FPU stack.
fld5=86,FPU

fld1=FSUBR
fld2=D8 /5
fld3=m32
fld4=Subtract ST(0) from single-precision float.
fld5=86,FPU

fld1=FSUBR
fld2=DC /5
fld3=m64
fld4=Subtract ST(0) from double-precision float.
fld5=86,FPU

fld1=FSUBP
fld2=DE E9
fld3=n/a
fld4=Subtract ST(0) from ST(1) and pop FPU stack.
fld5=86,FPU

fld1=FSUBR
fld2=D8 E8+i
fld3=ST(0), ST(i)
fld4=Subtract ST(0) from ST(i).
fld5=86,FPU

fld1=FSUBR
fld2=DC E0+i
fld3=ST(i), ST(0)
fld4=Subtract ST(i) from ST(0).
fld5=86,FPU

fld1=FSUBRP
fld2=DE E0+i
fld3=ST(i), ST(0)
fld4=Subtract ST(i) from ST(0) and pop FPU stack.
fld5=86,FPU

fld1=FSUBRP
fld2=DE E1
fld3=n/a
fld4=Subtract ST(1) from ST(0) and pop FPU stack.
fld5=86,FPU

fld1=FTST
fld2=D9 E4
fld3=n/a
fld4=Compare ST(0) with 0.0.
fld5=86,FPU

fld1=FUCOM
fld2=DD E0+i
fld3=ST(i)
fld4=Unordered compare ST(0) with ST(i).
fld5=386,FPU

fld1=FUCOMI
fld2=DB E8+i
fld3=ST, ST(i)
fld4=Unordered compare ST(0) with ST(i) and set CPU flags.
fld5=P6,FPU

fld1=FUCOMIP
fld2=DF E8+i
fld3=ST, ST(i)
fld4=Unordered compare ST(0) with ST(i), set CPU flags and pop FPU stack.
fld5=P6,FPU

fld1=FUCOMP
fld2=DD E8+i
fld3=ST(i)
fld4=Unordered compare ST(0) with ST(i) and pop FPU stack.
fld5=386,FPU

fld1=FUCOMPP
fld2=DA E9
fld3=n/a
fld4=Unordered compare ST(0) with ST(1) and pop FPU stack twice.
fld5=386,FPU

fld1=FXAM
fld2=D9 E5
fld3=n/a
fld4=Examine classi of value in ST(0).
fld5=86,FPU

fld1=FXCH
fld2=D9 C8+i
fld3=ST(i)
fld4=Exchange the contents of ST(0) and ST(i).
fld5=86,FPU

fld1=FXCH4
fld2=DD C8+i
fld3=ST(i)
fld4=Undocumented alias to FXCH ST(i).
fld5=86,FPU,UNDOC

fld1=FXCH7
fld2=DF C8+i
fld3=ST(i)
fld4=Undocumented alias to FXCH ST(i).
fld5=86,FPU,UNDOC

fld1=FXRSTOR
fld2=0F AE /mem|1
fld3=mem
fld4=Restore FP, MMX, SSE and SSE2 state.
fld5=P6,FPU,SSE

fld1=FXSAVE
fld2=0F AE /mem|0
fld3=mem
fld4=Save FP, MMX, SSE and SSE2 state.
fld5=P6,FPU,SSE

fld1=FXTRACT
fld2=D9 F4
fld3=n/a
fld4=Extract exponent and significand from ST(0).
fld5=86,FPU

fld1=FYL2X
fld2=D9 F1
fld3=n/a
fld4=Set ST(1) to ST(1) * log2(ST(0)) and pop FPU stack.
fld5=86,FPU

fld1=FYL2XP1
fld2=D9 F9
fld3=n/a
fld4=Set ST(1) to ST(1) * log2(ST(0)+1) and pop FPU stack.
fld5=86,FPU

fld1=HADDPD
fld2=66 0F 7C /r
fld3=xmm1, xmm2/m128
fld4=Add horizontally packed double-precision floats.
fld5=SSE3

fld1=HADDPS
fld2=F2 0F 7C /r
fld3=xmm1, xmm2/m128
fld4=Add horizontally packed single-precision floats.
fld5=SSE3

fld1=HLT
fld2=F4
fld3=n/a
fld4=Halt the processor.
fld5=86

fld1=HSUBPD
fld2=66 0F 7D /r
fld3=xmm1, xmm2/m128
fld4=Subtract horizontally packed double-precision floats.
fld5=SSE3

fld1=HSUBPS
fld2=F2 0F 7D /r
fld3=xmm1, xmm2/m128
fld4=Subtract horizontally packed single-precision floats.
fld5=SSE3

fld1=IBTS
fld2=0F A7 /r
fld3=r/m,r
fld4=Write bits from reg to r/m (only on the old 386s).
fld5=386,UNDOC

fld1=ICEBP
fld2=F1
fld3=n/a
fld4=One-byte form of INT 1.
fld5=P6,UNDOC

fld1=IDIV
fld2=F7 /7
fld3=r/m
fld4=Signed divide eDX:eAX by the operand.
fld5=86/386

fld1=IDIV
fld2=F6 /7
fld3=r/m8
fld4=Signed divide AX by the operand.
fld5=86

fld1=IMUL
fld2=F7 /5
fld3=r/m
fld4=Signed multiply operand by eAX.
fld5=86/386

fld1=IMUL
fld2=F6 /5
fld3=r/m8
fld4=Signed multiply operand by AL.
fld5=86

fld1=IMUL
fld2=69 /r iv
fld3=r, r/m, imm
fld4=Signed multiplation of two integers.
fld5=286

fld1=IMUL
fld2=6B /r ib
fld3=r, r/m, imm8
fld4=Signed multiplation of two integers.
fld5=286

fld1=IMUL
fld2=0F AF /r
fld3=r, r/m
fld4=Signed multiplation of two integers.
fld5=286

fld1=IN
fld2=EC
fld3=AL, DX
fld4=Input AL from I/O port.
fld5=86

fld1=IN
fld2=E4 ib
fld3=AL, imm8
fld4=Input AL from I/O port.
fld5=86

fld1=IN
fld2=ED
fld3=eAX, DX
fld4=Input eAX from I/O port.
fld5=86/386

fld1=IN
fld2=E5 ib
fld3=eAX, imm8
fld4=Input eAX from I/O port.
fld5=86/386

fld1=INC
fld2=40
fld3=eAX
fld4=Increment integer by 1.
fld5=86/386

fld1=INC
fld2=45
fld3=eBP
fld4=Increment integer by 1.
fld5=86/386

fld1=INC
fld2=43
fld3=eBX
fld4=Increment integer by 1.
fld5=86/386

fld1=INC
fld2=41
fld3=eCX
fld4=Increment integer by 1.
fld5=86/386

fld1=INC
fld2=47
fld3=eDI
fld4=Increment integer by 1.
fld5=86/386

fld1=INC
fld2=42
fld3=eDX
fld4=Increment integer by 1.
fld5=86/386

fld1=INC
fld2=46
fld3=eSI
fld4=Increment integer by 1.
fld5=86/386

fld1=INC
fld2=44
fld3=eSP
fld4=Increment integer by 1.
fld5=86/386

fld1=INC
fld2=FF /0
fld3=r/m
fld4=Increment integer by 1.
fld5=86/386

fld1=INC
fld2=FE /0
fld3=r/m8
fld4=Increment r/m byte by 1
fld5=86

fld1=INSB
fld2=6C
fld3=n/a
fld4=Input string byte from I/O port.
fld5=186

fld1=INSW/INSD
fld2=6D
fld3=m8, DX
fld4=Input string byte from I/O port.
fld5=186/386

fld1=INT
fld2=CC
fld3=3
fld4=One byte form of INT 3.
fld5=86

fld1=INT
fld2=CD ib
fld3=imm8
fld4=Software interrupt.
fld5=86

fld1=INTO
fld2=CE
fld3=n/a
fld4=Interrupt 4, if OF=1.
fld5=86

fld1=INVD
fld2=0F 08
fld3=n/a
fld4=Invalidate CPU internal caches.
fld5=486,PRIV

fld1=INVLPG
fld2=0F 01/7
fld3=m
fld4=Invalidate TLB entry.
fld5=486,PRIV

fld1=IRET/IRETD
fld2=CF
fld3=n/a
fld4=Return from Interrupt.
fld5=86

fld1=JA/JNBE
fld2=0F 87 iv
fld3=rel
fld4=Jump if above (CF=0 and ZF=0)
fld5=86

fld1=JA/JNBE
fld2=77 cb
fld3=rel8
fld4=Jump short if above (CF=0 and ZF=0)
fld5=386

fld1=JAE/JNB/JNC
fld2=0F 83 iv
fld3=rel
fld4=Jump if above or equal (CF=0)
fld5=86

fld1=JAE/JNB/JNC
fld2=73 cb
fld3=rel8
fld4=Jump short if above or equal (CF=0)
fld5=386

fld1=JB/JC/JNAE
fld2=0F 82 cw/cd
fld3=rel
fld4=Jump if below (CF=1)
fld5=386

fld1=JB/JC/JNAE
fld2=72 cb
fld3=rel8
fld4=Jump short if below (CF=1)
fld5=86

fld1=JBE/JNA
fld2=0F 86 cw/cd
fld3=rel
fld4=Jump if below or equal (CF=1 or ZF=1).
fld5=386

fld1=JBE/JNA
fld2=76 cb
fld3=rel8
fld4=Jump short if below or equal (CF=1 or ZF=1).
fld5=86

fld1=JCXZ/JECXZ
fld2=E3 cb
fld3=rel8
fld4=Jump short if eCX is 0.
fld5=86/386

fld1=JE/JZ
fld2=0F 84 iv
fld3=rel
fld4=Jump if equal (ZF=1).
fld5=386

fld1=JE/JZ
fld2=74 ib
fld3=rel8
fld4=Jump short if equal (ZF=1).
fld5=86

fld1=JG/JNLE
fld2=0F 8F iv
fld3=rel
fld4=Jump if greater (ZF=0 and SF=OF)
fld5=386

fld1=JG/JNLE
fld2=7F cb
fld3=rel8
fld4=Jump short if greater (ZF=0 and SF=OF)
fld5=86

fld1=JGE/JNL
fld2=0F 8D iv
fld3=rel
fld4=Jump near if greater or equal (SF=OF)
fld5=386

fld1=JGE/JNL
fld2=7D cb
fld3=rel8
fld4=Jump short if greater or equal (SF=OF)
fld5=86

fld1=JL/JNGE
fld2=0F 8C cw/cd
fld3=rel
fld4=Jump if less (SF<>OF)
fld5=386

fld1=JL/JNGE
fld2=7C cb
fld3=rel8
fld4=Jump short if less (SF<>OF)
fld5=86

fld1=JLE/JNG
fld2=0F 8E cw/cd
fld3=rel
fld4=Jump if less or equal (ZF=1 or SF<>OF)
fld5=386

fld1=JLE/JNG
fld2=7E cb
fld3=rel8
fld4=Jump short if less or equal (ZF=1 or SF<>OF)
fld5=86

fld1=JMP
fld2=EA iv iw
fld3=imm16:imm
fld4=a far absolute jump.
fld5=86

fld1=JMP
fld2=FF /5
fld3=m16:m
fld4=a far absolute indirect jump.
fld5=86

fld1=JMP
fld2=FF /4
fld3=r/m
fld4=A near absolute indirect jump.
fld5=86/386

fld1=JMP
fld2=E9 iv
fld3=rel
fld4=A near relative jump.
fld5=86

fld1=JMP
fld2=EB ib
fld3=rel8
fld4=A short relative jump.
fld5=86

fld1=JMPE
fld2=0F 00 /6
fld3=r/m
fld4=Transition from IA-32 mode to IA-64 mode.
fld5=ITANIUM

fld1=JMPE
fld2=0F B8 iv
fld3=rel
fld4=Transition from IA-32 mode to IA-64 mode.
fld5=ITANIUM

fld1=JNE/JNZ
fld2=0F 85 cw/cd
fld3=rel
fld4=Jump if not equal (ZF=0)
fld5=386

fld1=JNE/JNZ
fld2=75 ib
fld3=rel8
fld4=Jump short if not equal (ZF=0)
fld5=86

fld1=JNO
fld2=0F 81 iv
fld3=rel
fld4=Jump if not overflow (OF=0)
fld5=386

fld1=JNO
fld2=71 ib
fld3=rel8
fld4=Jump short if not overflow (OF=0)
fld5=86

fld1=JNP/JPO
fld2=0F 8B iv
fld3=rel
fld4=Jump if not parity (PF=0).
fld5=386

fld1=JNP/JPO
fld2=7B ib
fld3=rel8
fld4=Jump short if not parity (PF=0).
fld5=86

fld1=JNS
fld2=0F 89 iv
fld3=rel
fld4=Jump if not sign (SF=0).
fld5=386

fld1=JNS
fld2=79 ib
fld3=rel8
fld4=Jump short if not sign (SF=0).
fld5=86

fld1=JO
fld2=0F 80 iv
fld3=rel
fld4=Jump if overflow (OF=1).
fld5=386

fld1=JO
fld2=70 ib
fld3=rel8
fld4=Jump short if overflow (OF=1).
fld5=86

fld1=JP/JPE
fld2=0F 8A iv
fld3=rel
fld4=Jump if parity (PF=1).
fld5=386

fld1=JP/JPE
fld2=7A ib
fld3=rel8
fld4=Jump short if parity (PF=1).
fld5=86

fld1=JS
fld2=0F 88 iv
fld3=rel
fld4=Jump if sign (SF=1).
fld5=386

fld1=JS
fld2=78 ib
fld3=rel8
fld4=Jump short if sign (SF=1)
fld5=86

fld1=LAHF
fld2=9F
fld3=n/a
fld4=Load AH from CPU flags.
fld5=86

fld1=LAR
fld2=0F 02 /r
fld3=reg, r/m
fld4=Load access rights of the segment.
fld5=286

fld1=LDDQU
fld2=F2 0F F0 /r
fld3=xmm,m128
fld4=Load unaligned double-precision qword.
fld5=SSE3

fld1=LDMXCSR
fld2=0F AE /mem|2
fld3=m32
fld4=Load source into MXCSR.
fld5=SSE

fld1=LDS
fld2=C5 /r
fld3=reg, m16:mem
fld4=Load far pointer into DS and register.
fld5=86

fld1=LEA
fld2=8D /r
fld3=r32, m
fld4=Load effective address into register.
fld5=86/386

fld1=LEAVE
fld2=C9
fld3=n/a
fld4=Destroy stack frame used by procedure or sbroutine.
fld5=186

fld1=LES
fld2=C4 /r
fld3=r1 m16:mem
fld4=Load far pointer into ES and register.
fld5=86

fld1=LFENSE
fld2=0F AE /3|5
fld3=n/a
fld4=Load fence.
fld5=SSE2

fld1=LFS
fld2=0F B4 /r
fld3=reg, m16:mem
fld4=Load far pointer into FS and register.
fld5=386

fld1=LGDT
fld2=0F 01 /2
fld3=mem
fld4=Load source into GDTR.
fld5=286,PRIV

fld1=LGS
fld2=0F B5 /r
fld3=r, m16:mem
fld4=Load far pointer into GS and register.
fld5=386

fld1=LIDT
fld2=0F 01 /3
fld3=mem
fld4=Load source into IDTR.
fld5=286,PRIV

fld1=LLDT
fld2=0F 00 /2
fld3=r/m16
fld4=Load source into LDTR.
fld5=286,PRIV

fld1=LMSW
fld2=0F 01 /6
fld3=r/m16
fld4=Load source into MSW (bottom 4 bits of CR(0).
fld5=286,PRIV

fld1=LOADALL
fld2=0F 07
fld3=n/a
fld4=Load processor state (on some 386 & 486s).
fld5=386,UNDOC

fld1=LOADALL286
fld2=0F 04
fld3=n/a
fld4=Load processor state (only on 286).
fld5=286,UNDOC

fld1=LOADALL286
fld2=0F 05
fld3=n/a
fld4=Load processor state (only on 286).
fld5=286,UNDOC

fld1=LOCK (prefix)
fld2=F0
fld3=n/a
fld4=Exclusive use of memory in multiprocessor system.
fld5=86

fld1=LODSB
fld2=AC
fld3=n/a
fld4=Load a byte from string.
fld5=86

fld1=LODSW/LODSD
fld2=AD
fld3=n/a
fld4=Load a word/dword from string.
fld5=86/386

fld1=LOOP
fld2=E2 ib
fld3=rel8
fld4=Decrement eCX and jump if eCX<>0.
fld5=86

fld1=LOOPE/LOOPZ
fld2=E1 ib
fld3=rel8
fld4=Decrement eCX and jump if eCX<>0 and ZF=1.
fld5=86

fld1=LOOPNE/LOOPNZ
fld2=E0 ib
fld3=rel8
fld4=Decrement eCX and jump if eCX<>0 and ZF=0.
fld5=86

fld1=LSL
fld2=0F 03 /r
fld3=reg, r/m
fld4=Load segment limit.
fld5=286

fld1=LSS
fld2=0F B2 /r
fld3=reg, m16:mem
fld4=Load far pointer into SS and register.
fld5=386

fld1=LTR
fld2=0F 00 /3
fld3=r/m16
fld4=Load source into TR.
fld5=286,PRIV

fld1=MASKMOVDQU
fld2=66 0F F7 /r
fld3=xmm1, xmm2
fld4=Store selected bytes of dword.
fld5=SSE2

fld1=MASKMOVQ
fld2=0F F7 /r
fld3=mm1, mm2
fld4=Store selected bytes of qword.
fld5=SSE

fld1=MAXPD
fld2=66 0F 5F /r
fld3=xmm1, xmm2/m128
fld4=Maximum of packed double-precision floats.
fld5=SSE2

fld1=MAXPS
fld2=0F 5F /r
fld3=xmm1, xmm2/m128
fld4=Maximum of packed single-precision floats.
fld5=SSE

fld1=MAXSD
fld2=F2 0F 5F /r
fld3=xmm1, xmm2/m64
fld4=Maximum of scalar double-precision floats.
fld5=SSE2

fld1=MAXSS
fld2=F3 0F 5F /r
fld3=xmm1, xmm2/m32
fld4=Maximum of scalar single-precision floats.
fld5=SSE

fld1=MFENCE
fld2=0F AE /6
fld3=n/a
fld4=Memory fence.
fld5=SSE2

fld1=MINPD
fld2=66 0F 5D /r
fld3=xmm1, xmm2/m128
fld4=Minimum of packed double-precision floats.
fld5=SSE2

fld1=MINPS
fld2=0F 5D /r
fld3=xmm1, xmm2/m128
fld4=Minimum of packed single-precision floats.
fld5=SSE

fld1=MINSD
fld2=F2 0F 5D /r
fld3=xmm1, xmm2/m64
fld4=Minimum of scalar double-precision floats.
fld5=SSE2

fld1=MINSS
fld2=F3 0F 5D /r
fld3=xmm1, xmm2/m32
fld4=Minimum of scalar single-precision floats.
fld5=SSE

fld1=MONITOR
fld2=0F 01 C8
fld3=n/a
fld4=Setup monitor address from EAX.
fld5=SSE3

fld1=MOV AH
fld2=B4 ib
fld3=imm8
fld4=Move immediate value into register.
fld5=86

fld1=MOV AL
fld2=B0 ib
fld3=imm8
fld4=Move immediate value into register.
fld5=86

fld1=MOV AL
fld2=A0 ib
fld3=moffs8
fld4=Move source into register.
fld5=86

fld1=MOV BH
fld2=B7 ib
fld3=imm8
fld4=Move immediate value into register.
fld5=86

fld1=MOV BL
fld2=B3 ib
fld3=imm8
fld4=Move immediate value into register.
fld5=86

fld1=MOV CH
fld2=B5 ib
fld3=imm8
fld4=Move immediate value into register.
fld5=86

fld1=MOV CL
fld2=B1 ib
fld3=imm8
fld4=Move immediate value into register.
fld5=86

fld1=MOV CR0/2/3/4
fld2=0F 22 /r
fld3=reg32
fld4=Move register into control register.
fld5=386/PRIV

fld1=MOV DH
fld2=B6 ib
fld3=imm8
fld4=Move immediate value into register.
fld5=86

fld1=MOV DL
fld2=B2 ib
fld3=imm8
fld4=Move immediate value into register.
fld5=86

fld1=MOV DR0/1/2/3/6/7
fld2=0F 23 /r
fld3=reg32
fld4=Move register into debug register.
fld5=386,PRIV

fld1=MOV eAX
fld2=B8 iv
fld3=imm
fld4=Move immediate value into register.
fld5=86,386

fld1=MOV eAX
fld2=A1 iv
fld3=moffs
fld4=Move source into register.
fld5=86,386

fld1=MOV eBP
fld2=BD iv
fld3=imm
fld4=Move immediate value into register.
fld5=86,386

fld1=MOV eBX
fld2=BB iv
fld3=imm
fld4=Move immediate value into register.
fld5=86,386

fld1=MOV eCX
fld2=B9 iv
fld3=imm
fld4=Move immediate value into register.
fld5=86,386

fld1=MOV eDI
fld2=BF iv
fld3=imm
fld4=Move immediate value into register.
fld5=86,386

fld1=MOV eDX
fld2=BA iv
fld3=imm
fld4=Move immediate value into register.
fld5=86,386

fld1=MOV eSI
fld2=BE iv
fld3=imm
fld4=Move immediate value into register.
fld5=86,386

fld1=MOV eSP
fld2=BC iv
fld3=imm
fld4=Move immediate value into register.
fld5=86,386

fld1=MOV
fld2=A3 iv
fld3=moffs,eAX
fld4=Move register into destination.
fld5=86,386

fld1=MOV
fld2=A2 ib
fld3=moffs8,AL
fld4=Move register into destination.
fld5=86

fld1=MOV
fld2=C7 /0 iv
fld3=r/m,imm
fld4=Move immediate value into register.
fld5=86

fld1=MOV
fld2=89 /r
fld3=r/m,reg
fld4=Move register into destination.
fld5=86/386

fld1=MOV
fld2=8C /r
fld3=r/m, sreg
fld4=Move segment register into destination.
fld5=86

fld1=MOV
fld2=C6 /0 ib
fld3=r/m8,imm8
fld4=Move immediate value into destination.
fld5=86

fld1=MOV
fld2=88 /r
fld3=r/m8,reg8
fld4=Move register into destination.
fld5=86

fld1=MOV
fld2=8B /r
fld3=reg,r/m
fld4=Move source into register.
fld5=86,386

fld1=MOV
fld2=0F 20 /r
fld3=reg32,CR0/2/3/4
fld4=Move control register into register.
fld5=386

fld1=MOV
fld2=0F 21 /r
fld3=reg32,DR0/1/2/3/6/7
fld4=Move debug register into register.
fld5=386

fld1=MOV
fld2=0F 24 /r
fld3=reg32,TR3/4/5/6/7
fld4=Move test register into register.
fld5=386

fld1=MOV
fld2=8A /r
fld3=reg8,r/m8
fld4=Move source into register.
fld5=86

fld1=MOV
fld2=8E /r
fld3=sreg,r/m
fld4=Move source into segment register.
fld5=86

fld1=MOV
fld2=0F 26 /r
fld3=TR3/4/5/6/7,reg32
fld4=Move register into test register.
fld5=386

fld1=MOVAPD
fld2=66 0F 28 /r
fld3=xmm1, xmm2/m128
fld4=Move aligned packed double-precision floats.
fld5=SSE2

fld1=MOVAPD
fld2=66 0F 29 /r
fld3=xmm2/m128, xmm1
fld4=Move aligned packed double-precision floats.
fld5=SSE2

fld1=MOVAPS
fld2=0F 28 /r
fld3=xmm1,xmm2/m128
fld4=Move aligned packed single-precision floats.
fld5=SSE

fld1=MOVAPS
fld2=0F 29 /r
fld3=xmm1/m128,xmm2
fld4=Move aligned packed single-precision floats.
fld5=SSE

fld1=MOVD
fld2=0F 6E /r
fld3=mm,r/m32
fld4=Move dword to MMX register.
fld5=MMX

fld1=MOVD
fld2=0F 7E /r
fld3=r/m32, mm
fld4=Move dword from MMX register.
fld5=MMX

fld1=MOVD
fld2=66 0F 7E /r
fld3=r/m32,xmm
fld4=Move dword to XMM register.
fld5=SSE2

fld1=MOVD
fld2=66 0F 6E /r
fld3=xmm,r/m32
fld4=Move dword from XMM register.
fld5=SSE2

fld1=MOVDDUP
fld2=F2 0F 12 /r
fld3=xmm1,xmm2/m128
fld4=Move packed double-precision float and duplicate it.
fld5=SSE3

fld1=MOVDQ2Q
fld2=F2 0F D6 /r
fld3=mm,xmm
fld4=Move dword from XMM to MMX register.
fld5=SSE2

fld1=MOVDQA
fld2=66 0F 6F /r
fld3=xmm1,xmm2/m128
fld4=Move aligned double qword.
fld5=SSE2

fld1=MOVDQA
fld2=66 0F 7F /r
fld3=xmm2/m128,xmm1
fld4=Move aligned double qword.
fld5=SSE2

fld1=MOVDQU
fld2=F3 0F 6F /r
fld3=xmm1,xmm2/m128
fld4=Move unaligned double qword.
fld5=SSE2

fld1=MOVDQU
fld2=F3 0F 7F /r
fld3=xmm1,m128/xmm2
fld4=Move unaligned double qword.
fld5=SSE2

fld1=MOVHLPS
fld2=OF 12 /3|r
fld3=xmm1,xmm2
fld4=Move packed single-precision floats values from high to low.
fld5=SSE

fld1=MOVHPD
fld2=66 0F 17 /r
fld3=m64,xmm
fld4=Move high packed double-precision floats.
fld5=SSE2

fld1=MOVHPD
fld2=66 0F 16 /r
fld3=xmm,m64
fld4=Move high packed double-precision floats.
fld5=SSE2

fld1=MOVHPS
fld2=0F 17 /r
fld3=m64,xmm
fld4=Move high packed single-precision floats.
fld5=SSE

fld1=MOVHPS
fld2=0F 16 /mem|r
fld3=xmm, m64
fld4=Move high packed single-precision floats.
fld5=SSE

fld1=MOVLHPS
fld2=OF 16 /3|r
fld3=xmm1,xmm2
fld4=Move packed single-precision floats from low to high.
fld5=SSE

fld1=MOVLPD
fld2=66 0F 13 /r
fld3=m64,xmm
fld4=Move low packed double-precision floats.
fld5=SSE2

fld1=MOVLPD
fld2=66 0F 12 /r
fld3=xmm,m64
fld4=Move low packed double-precision floats.
fld5=SSE2

fld1=MOVLPS
fld2=0F 13 /r
fld3=m64,xmm
fld4=Move low packed double-precision floats.
fld5=SSE

fld1=MOVLPS
fld2=0F 12 /mem|r
fld3=xmm,m64
fld4=Move low packed single-precision floats.
fld5=SSE

fld1=MOVMSKPD
fld2=66 0F 50 /r
fld3=reg32,xmm
fld4=Extract packed double-precision float sign mask.
fld5=SSE2

fld1=MOVMSKPS
fld2=0F 50 /r
fld3=reg32,xmm
fld4=Extract packed single-precision float sign mask.
fld5=SSE

fld1=MOVNTDQ
fld2=66 0F E7 /r
fld3=m128,xmm
fld4=Move double-precision qword preventing caching.
fld5=SSE2

fld1=MOVNTI
fld2=0F C3 /r
fld3=m32,reg32
fld4=Move dword preventing caching.
fld5=SSE2

fld1=MOVNTPD
fld2=66 0F 2B /r
fld3=m128,xmm
fld4=Move packed double-precision float preventing caching.
fld5=SSE2

fld1=MOVNTPS
fld2=0F 2B /r
fld3=m128,xmm
fld4=Move packed single-precision float preventing caching.
fld5=SSE

fld1=MOVNTQ
fld2=0F E7 /r
fld3=m64,mm
fld4=Move qword preventing caching.
fld5=SSE

fld1=MOVQ
fld2=0F 6F /r
fld3=mm1,mm2/m64
fld4=Move qword to MMX register.
fld5=MMX

fld1=MOVQ
fld2=0F 7F /r
fld3=mm1/m64,mm2
fld4=Move qword from MMX register.
fld5=MMX

fld1=MOVQ
fld2=F3 0F 7E /r
fld3=xmm1,xmm2/m64
fld4=Move qword to XMM register.
fld5=SSE2

fld1=MOVQ
fld2=66 0F D6 /r
fld3=xmm2/m64,xmm1
fld4=Move qword from XMM register.
fld5=SSE2

fld1=MOVQ2DQ
fld2=F3 0F D6 /r
fld3=xmm,mm
fld4=Move qword from MMX to XMM register.
fld5=SSE2

fld1=MOVSB
fld2=A4
fld3=n/a
fld4=Move abyte from string to string.
fld5=86

fld1=MOVSD
fld2=F2 0F 10 /r
fld3=xmm1,xmm2/m64
fld4=Move scalar double-precision float.
fld5=SSE2

fld1=MOVSD
fld2=F2 0F 11 /r
fld3=xmm2/m64,xmm1
fld4=Move scalar double-precision float.
fld5=SSE2

fld1=MOVSHDUP
fld2=F3 0F 16 /r
fld3=xmm1,xmm2/m128
fld4=Move high packed single-precision floats and duplicate them.
fld5=SSE3

fld1=MOVSLDUP
fld2=F3 0F 12 /r
fld3=xmm2/m128,xmm1
fld4=Move low packed single-precision floats and duplicate them.
fld5=SSE3

fld1=MOVSS
fld2=F3 0F 10 /r
fld3=xmm1,xmm2/m64
fld4=Move scalar double-precision float.
fld5=SSE

fld1=MOVSS
fld2=F3 0F 11 /r
fld3=xmm2/m64,xmm1
fld4=Move scalar double-precision float.
fld5=SSE

fld1=MOVSW/MOVSD
fld2=A5
fld3=n/a
fld4=Move word/dword from string to string.
fld5=86/386

fld1=MOVSX
fld2=0F BE /r
fld3=reg,r/m8
fld4=Move byte to word with sign-extension.
fld5=386

fld1=MOVSX
fld2=0F BF /r
fld3=reg32,r/m16
fld4=Move word to doubleword, sign-extension.
fld5=386

fld1=MOVUPD
fld2=66 0F 10 /r
fld3=xmm1, xmm2/m128
fld4=Move unaligned packed double-precision floats.
fld5=SSE2

fld1=MOVUPD
fld2=66 0F 11 /r
fld3=xmm2/m128, xmm
fld4=Move unaligned packed double-precision floats.
fld5=SSE2

fld1=MOVUPS
fld2=0F 10 /r
fld3=xmm1,xmm2/m128
fld4=Move unaligned packed single-precision floats.
fld5=SSE

fld1=MOVUPS
fld2=0F 11 /r
fld3=xmm2/m128,xmm1
fld4=Move unaligned packed single-precision floats.
fld5=SSE

fld1=MOVZX
fld2=0F B6 /r
fld3=reg,r/m8
fld4=Move byte to word with zero-extension.
fld5=386

fld1=MOVZX
fld2=0F B7 /r
fld3=reg32,r/m16
fld4=Move word to doubleword with zero-extension.
fld5=386

fld1=MUL
fld2=F7 /4
fld3=r/m
fld4=Unsigned multiply operand by eAX.
fld5=86/386

fld1=MUL
fld2=F6 /4
fld3=r/m8
fld4=Unsigned multiply operand by AL.
fld5=86

fld1=MULPD
fld2=66 0F 59 /r
fld3=xmm1,xmm2/m128
fld4=Multiply packed double-precision floats.
fld5=SSE2

fld1=MULPS
fld2=0F 59 /r
fld3=xmm1,xmm2/m128
fld4=Multiply packed single-precision floats.
fld5=SSE

fld1=MULSD
fld2=F2 0F 59 /r
fld3=xmm1,xmm2/m64
fld4=Multiply scalar double-precision floats.
fld5=SSE2

fld1=MULSS
fld2=F3 0F 59 /r
fld3=xmm1,xmm2/m32
fld4=Multiply scalar double-precision floats.
fld5=SSE

fld1=MWAIT
fld2=0F 01 C9
fld3=n/a
fld4=Monitor wait hint.
fld5=SSE3

fld1=NEG
fld2=F7 /3
fld3=r/m
fld4=Two’s complement negation.
fld5=86/386

fld1=NEG
fld2=F6 /3
fld3=r/m8
fld4=Two’s complement negation.
fld5=86

fld1=No mnemonics
fld2=D4 ib
fld3=n/a
fld4=ASCII adjust AX after multiply.
fld5=86

fld1=No mnemonics
fld2=D5 ib
fld3=n/a
fld4=ASCII adjust AX before division.
fld5=86

fld1=NOP
fld2=90
fld3=n/a
fld4=No operation
fld5=86

fld1=NOT
fld2=F7 /2
fld3=r/m
fld4=Ones’s complement negation.
fld5=86/386

fld1=NOT
fld2=F6 /2
fld3=r/m8
fld4=Ones’s complement negation.
fld5=86

fld1=OR
fld2=0C ib
fld3=AL,imm8
fld4=Bitwise OR of two integers.
fld5=86

fld1=OR
fld2=0D iv
fld3=eAX,imm
fld4=Bitwise OR of two integers.
fld5=86/386

fld1=OR
fld2=81 /1 iv
fld3=r/m,imm
fld4=Bitwise OR of two integers.
fld5=86/386

fld1=OR
fld2=83 /1 ib
fld3=r/m,imm8
fld4=Bitwise OR of two integers.
fld5=86/386

fld1=OR
fld2=09 /r
fld3=r/m,reg
fld4=Bitwise OR of two integers.
fld5=86/386

fld1=OR
fld2=80 /1 ib
fld3=r/m8,imm8
fld4=Bitwise OR of two integers.
fld5=86

fld1=OR
fld2=82 /1 ib
fld3=r/m8,imm8
fld4=Bitwise OR of two integers.
fld5=86

fld1=OR
fld2=08 /r
fld3=r/m8,reg8
fld4=Bitwise OR of two integers.
fld5=86

fld1=OR
fld2=0B /r
fld3=reg,r/m
fld4=Bitwise OR of two integers.
fld5=86/386

fld1=OR
fld2=0A /r
fld3=reg8,r/m8
fld4=Bitwise OR of two integers.
fld5=86

fld1=ORPD
fld2=66 0F 56 /r
fld3=xmm1, xmm2/m128
fld4=Bitwise OR of packed double-precision floats.
fld5=SSE2

fld1=ORPS
fld2=0F 56 /r
fld3=xmm1,xmm2/m128
fld4=Bitwise OR of packed single-precision floats.
fld5=SSE

fld1=OUT
fld2=EE
fld3=DX,AL
fld4=Output AL to I/O port.
fld5=86

fld1=OUT
fld2=EF
fld3=DX,eAX
fld4=Output eAX to I/O port.
fld5=86,386

fld1=OUT
fld2=E6 ib
fld3=imm8,AL
fld4=Output AL to I/O port.
fld5=86

fld1=OUT
fld2=E7 ib
fld3=imm8,eAX
fld4=Output eAX to I/O port.
fld5=86/386

fld1=OUTSB
fld2=6E
fld3=n/a
fld4=Output string byte to I/O port.
fld5=186

fld1=OUTSW/OUTSD
fld2=6F
fld3=n/a
fld4=Output string word/dword to I/O port.
fld5=186/386

fld1=PACKSSDW
fld2=0F 6B /r
fld3=mm1,mm2/m64
fld4=Pack dwords to words with signed saturation.
fld5=MMX

fld1=PACKSSDW
fld2=66 0F 6B /r
fld3=xmm1,xmm2/m128
fld4=Pack dwords to words with signed saturation.
fld5=SSE2

fld1=PACKSSWB
fld2=0F 63 /r
fld3=mm1,mm2/m64
fld4=Pack words to bytes with signed saturation.
fld5=MMX

fld1=PACKSSWB
fld2=66 0F 63 /r
fld3=xmm1,xmm2/m128
fld4=Pack words to bytes with signed saturation.
fld5=SSE2

fld1=PACKUSWB
fld2=0F 67 /r
fld3=mm1,mm2/m64
fld4=Pack words to bytes with unsigned saturation.
fld5=MMX

fld1=PACKUSWB
fld2=66 0F 67 /r
fld3=xmm1,xmm2/m128
fld4=Pack words to bytes with unsigned saturation.
fld5=SSE2

fld1=PADDB
fld2=0F FC /r
fld3=mm1,mm2/m64
fld4=Add packed byte integers.
fld5=MMX

fld1=PADDB
fld2=66 0F FC /r
fld3=xmm1,xmm2/m128
fld4=Add packed byte integers.
fld5=SSE2

fld1=PADDD
fld2=0F FE /r
fld3=mm1,mm2/m64
fld4=Add packed dword integers.
fld5=MMX

fld1=PADDD
fld2=66 0F FE /r
fld3=xmm1,xmm2/m128
fld4=Add packed dword integers.
fld5=SSE2

fld1=PADDQ
fld2=0F D4 /r
fld3=mm1,mm2/m64
fld4=Add packed qword integers.
fld5=MMX

fld1=PADDQ
fld2=66 0F D4 /r
fld3=xmm1,xmm2/m128
fld4=Add packed qword integers.
fld5=SSE2

fld1=PADDSB
fld2=0F EC /r
fld3=mm1,mm2/m64
fld4=Add packed byte integers with signed saturation.
fld5=MMX

fld1=PADDSB
fld2=66 0F EC /r
fld3=xmm1,xmm2/m128
fld4=Add packed byte integers with signed saturation.
fld5=SSE2

fld1=PADDSIW
fld2=0F 51 /r
fld3=mm,r/m64
fld4=Add packed words and store to implicit register.
fld5=MMX,CYRYX

fld1=PADDSW
fld2=0F ED /r
fld3=mm1,mm2/m64
fld4=Add packed word integers with signed saturation.
fld5=MMX

fld1=PADDSW
fld2=66 0F ED /r
fld3=xmm1,xmm2/m128
fld4=Add packed word integers with signed saturation.
fld5=SSE2

fld1=PADDUSB
fld2=0F DC /r
fld3=mm1,mm2/m64
fld4=Add packed byte integers with unsigned saturation.
fld5=MMX

fld1=PADDUSB
fld2=66 0F DC /r
fld3=xmm1,xmm2/m128
fld4=Add packed byte integers with unsigned saturation.
fld5=SSE2

fld1=PADDUSW
fld2=0F DD /r
fld3=mm1,mm2/m64
fld4=Add packed word integers with unsigned saturation.
fld5=MMX

fld1=PADDUSW
fld2=66 0F DD /r
fld3=xmm1,xmm2/m128
fld4=Add packed word integers with unsigned saturation.
fld5=SSE2

fld1=PADDW
fld2=0F FD /r
fld3=mm1,mm2/m64
fld4=Add packed word integers.
fld5=MMX

fld1=PADDW
fld2=66 0F FD /r
fld3=xmm1,xmm2/m128
fld4=Add packed word integers.
fld5=SSE2

fld1=PAND
fld2=0F DB /r
fld3=mm1,mm2/m64
fld4=Bitwise AND of MMX register.
fld5=MMX

fld1=PAND
fld2=66 0F DB /r
fld3=xmm1,xmm2/m128
fld4=Bitwise AND of XMM register.
fld5=SSE2

fld1=PANDN
fld2=0F DF /r
fld3=mm1,mm2/m64
fld4=Bitwise AND NOT of MMX register.
fld5=MMX

fld1=PANDN
fld2=66 0F DF /r
fld3=xmm1,xmm2/m128
fld4=Bitwise AND NOT of XMM register.
fld5=SSE2

fld1=PAUSE
fld2=F3 90
fld3=n/a
fld4=Hint to processor that improves performance of spin loops.
fld5=SSE2

fld1=PAVEB
fld2=0F 50 /r
fld3=mm, r/m64
fld4=Average of 8 packed bytes.
fld5=MMX,CYRIX

fld1=PAVGB
fld2=0F E0 /r
fld3=mm1,mm2/m64
fld4=Average of packed byte integers.
fld5=SSE

fld1=PAVGB
fld2=66 0F E0, /r
fld3=xmm1,xmm2/m128
fld4=Average of packed byte integers.
fld5=SSE2

fld1=PAVGUSB
fld2=0F 0F /r BF
fld3=mm1,mm2/m64
fld4=Average of unsigned packed bytes.
fld5=3DNOW

fld1=PAVGW
fld2=0F E3 /r
fld3=mm1,mm2/m64
fld4=Average of packed word integers.
fld5=SSE

fld1=PAVGW
fld2=66 0F E3 /r
fld3=xmm1,xmm2/m128
fld4=Average of packed word integers.
fld5=SSE2

fld1=PCMPEQB
fld2=0F 74 /r
fld3=mm1,mm2/m64
fld4=Compare packed bytes for equality.
fld5=MMX

fld1=PCMPEQB
fld2=66 0F 74 /r
fld3=xmm1,xmm2/m128
fld4=Compare packed bytes for equality.
fld5=SSE2

fld1=PCMPEQD
fld2=0F 76 /r
fld3=mm1,mm2/m64
fld4=Compare packed dwords for equality.
fld5=MMX

fld1=PCMPEQD
fld2=66 0F 76 /r
fld3=xmm1,xmm2/m128
fld4=Compare packed dwords for equality.
fld5=SSE2

fld1=PCMPEQW
fld2=0F 75 /r
fld3=mm1,mm2/m64
fld4=Compare packed words for equality.
fld5=MMX

fld1=PCMPEQW
fld2=66 0F 75 /r
fld3=xmm1,xmm2/m128
fld4=Compare packed words for equality.
fld5=SSE2

fld1=PCMPGTB
fld2=0F 64 /r
fld3=mm1,mm2/m64
fld4=Compare packed bytes for greater-than.
fld5=MMX

fld1=PCMPGTB
fld2=66 0F 64 /r
fld3=xmm1, xmm2/m128
fld4=Compare packed bytes for greater-than.
fld5=SSE2

fld1=PCMPGTD
fld2=0F 66 /r
fld3=mm1,mm2/m64
fld4=Compare packed dwords for greater-than.
fld5=MMX

fld1=PCMPGTD
fld2=66 0F 66 /r
fld3=xmm1,xmm2/m128
fld4=Compare packed dwords for greater-than.
fld5=SSE2

fld1=PCMPGTW
fld2=0F 65 /r
fld3=mm1,mm2/m64
fld4=Compare packed words for greater-than.
fld5=MMX

fld1=PCMPGTW
fld2=66 0F 65 /r
fld3=xmm1,xmm2/m128
fld4=Compare packed words for greater-than.
fld5=SSE2

fld1=PDISTIB
fld2=0F 54 /r
fld3=mm,m64
fld4=Packed distance and accumulate with implied register.
fld5=MMX,CYRIX

fld1=PEXTRW
fld2=0F C5 /r ib
fld3=reg32,mm,imm8
fld4=Extract the word from MMX register.
fld5=SSE

fld1=PEXTRW
fld2=66 0F C5 /r ib
fld3=reg32,xmm,imm8
fld4=Extract the word from XMM register.
fld5=SSE2

fld1=PF2ID
fld2=0F 0F /r 1D
fld3=mm1,mm2/m64
fld4=Convert packed single-precision floats to dwords.
fld5=3DNOW

fld1=PF2IW
fld2=0F 0F /r 1C
fld3=mm1,mm2/m64
fld4=Convert packed single-precision floats to words.
fld5=3DNOW

fld1=PFACC
fld2=0F 0F /r AE
fld3=mm1,mm2/m64
fld4=Accumulate packed single-precision floats.
fld5=3DNOW

fld1=PFADD
fld2=0F 0F /r 9E
fld3=mm1,mm2/m64
fld4=Add packed single-precision floats.
fld5=3DNOW

fld1=PFCMPEQ
fld2=0F 0F /r B0
fld3=mm1,mm2/m64
fld4=Compare packed single-precision floats for equality.
fld5=3DNOW

fld1=PFCMPGE
fld2=0F 0F /r 90
fld3=mm1,mm2/m64
fld4=Compare packed single-precision floats for greater-than-or-equal.
fld5=3DNOW

fld1=PFCMPGT
fld2=0F 0F /r A0
fld3=mm1,mm2/m64
fld4=Compare packed single-precision floats for greater-than.
fld5=3DNOW

fld1=PFMAX
fld2=0F 0F /r A4
fld3=mm1,mm2/m64
fld4=Maximum of packed single-precision floats.
fld5=3DNOW

fld1=PFMIN
fld2=0F 0F /r 94
fld3=mm1,mm2/m64
fld4=Minimum of packed single-precision floats.
fld5=3DNOW

fld1=PFMUL
fld2=0F 0F /r B4
fld3=mm1,mm2/m64
fld4=Multiply packed single-precision floats.
fld5=3DNOW

fld1=PFNACC
fld2=0F 0F /r 8A
fld3=mm1,mm2/m64
fld4=Negative accumulate packed single-precision floats.
fld5=3DNOW

fld1=PFPNACC
fld2=0F 0F /r 8E
fld3=mm1,mm2/m64
fld4=Mixed accumulate packed single-precision floats.
fld5=3DNOW

fld1=PFRCP
fld2=0F 0F /r 96
fld3=mm1,mm2/m64
fld4=Reciprocal approximation of packed single-precision floats.
fld5=3DNOW

fld1=PFRCPIT1
fld2=0F 0F /r A6
fld3=mm1,mm2/m64
fld4=Reciprocal of packed single-precision float, 1st step.
fld5=3DNOW

fld1=PFRCPIT2
fld2=0F 0F /r B6
fld3=mm1,mm2/m64
fld4=Reciprocal of packed single-precision float, 2nd step.
fld5=3DNOW

fld1=PFRSQIT1
fld2=0F 0F /r A7
fld3=mm1,mm2/m64
fld4=Reciprocal of packed single-precision float square root, 1st step.
fld5=3DNOW

fld1=PFRSQRT
fld2=0F 0F /r 97
fld3=mm1,mm2/m64
fld4=Reciprocal of packed single-precision float square root.
fld5=3DNOW

fld1=PFSUB
fld2=0F 0F /r 9A
fld3=mm1,mm2/m64
fld4=Subtract packed single-precision floats.
fld5=3DNOW

fld1=PFSUBR
fld2=0F 0F /r AA
fld3=mm1,mm2/m64
fld4=Reverse subtract packed single-precision floats.
fld5=3DNOW

fld1=PI2FD
fld2=0F 0F /r 0D
fld3=mm1,mm2/m64
fld4=Converts dwords to packed single-precision floats.
fld5=3DNOW

fld1=PI2FD
fld2=0F 0F /r 0C
fld3=mm1,mm2/m64
fld4=Converts words to packed single-precision floats.
fld5=3DNOW

fld1=PINSRW
fld2=0F C4 /r ib
fld3=mm,reg32/m16,imm8
fld4=Insert word into MMX register.
fld5=SSE

fld1=PINSRW
fld2=66 0F C4 /r ib
fld3=xmm,reg32/m16,imm8
fld4=Insert word into XMM register.
fld5=SSE2

fld1=PMACHRIW
fld2=0F 5E /r
fld3=mm,m64
fld4=Packed multiply and accumulate with rounding.
fld5=MMX,CYRIX

fld1=PMADDWD
fld2=0F F5 /r
fld3=mm1,mm2/m64
fld4=Multiply and add packed integers.
fld5=MMX

fld1=PMADDWD
fld2=66 0F F5 /r
fld3=xmm1,xmm2/m128
fld4=Multiply and add packed integers.
fld5=SSE2

fld1=PMAGW
fld2=0F 52 /r
fld3=mm1,mm2/m64
fld4=Packed magnitude of 4 words.
fld5=MMX,CYRIX

fld1=PMAXSW
fld2=0F EE /r
fld3=mm1,mm2/m64
fld4=Maximum of packed signed word integers.
fld5=SSE

fld1=PMAXSW
fld2=66 0F EE /r
fld3=xmm1,xmm2/m128
fld4=Maximum of packed signed word integers.
fld5=SSE2

fld1=PMAXUB
fld2=0F DE /r
fld3=mm1,mm2/m64
fld4=Maximum of packed unsigned byte integers.
fld5=SSE

fld1=PMAXUB
fld2=66 0F DE /r
fld3=xmm1,xmm2/m128
fld4=Maximum of packed unsigned byte integers.
fld5=SSE2

fld1=PMINSW
fld2=0F EA /r
fld3=mm1,mm2/m64
fld4=Minimum of packed signed word integers.
fld5=SSE

fld1=PMINSW
fld2=66 0F EA /r
fld3=xmm1,xmm2/m128
fld4=Minimum of packed signed word integers.
fld5=SSE2

fld1=PMINUB
fld2=0F DA /r
fld3=mm1,mm2/m64
fld4=Minimum of packed unsigned byte integers.
fld5=SSE

fld1=PMINUB
fld2=66 0F DA /r
fld3=xmm1,xmm2/m128
fld4=Minimum of packed unsigned byte integers.
fld5=SSE2

fld1=PMOVMSKB
fld2=0F D7 /r
fld3=reg32,mm
fld4=Move byte mask to register.
fld5=SSE

fld1=PMOVMSKB
fld2=66 0F D7 /r
fld3=reg32,xmm
fld4=Move byte mask to register.
fld5=SSE2

fld1=PMULHRIW
fld2=0F 5D /r
fld3=mm1,mm2/m64
fld4=Multiply packed words and round to implicit register.
fld5=MMX,CYRIX

fld1=PMULHRW
fld2=0F 0F /r B7
fld3=mm1,mm2/m64
fld4=Multiply packed words, round and store high word.
fld5=3DNOW

fld1=PMULHRWC
fld2=0F 59 /r
fld3=mm1,mm2/m64
fld4=Multiply packed words, round and store high word.
fld5=MMX,CYRIX

fld1=PMULHUW
fld2=0F E4 /r
fld3=mm1,mm2/m64
fld4=Multiply packed unsigned words and store high word.
fld5=SSE

fld1=PMULHUW
fld2=66 0F E4 /r
fld3=xmm1,xmm2/m128
fld4=Multiply packed unsigned words and store high word.
fld5=SSE2

fld1=PMULHW
fld2=0F E5 /r
fld3=mm1,mm2/m64
fld4=Multiply packed signed words and store high word.
fld5=MMX

fld1=PMULHW
fld2=66 0F E5 /r
fld3=xmm1,xmm2/m128
fld4=Multiply packed signed words and store high word.
fld5=SSE2

fld1=PMULLW
fld2=0F D5 /r
fld3=mm1,mm2/m64
fld4=Multiply packed signed words and store low word.
fld5=MMX

fld1=PMULLW
fld2=66 0F D5 /r
fld3=xmm1,xmm2/m128
fld4=Multiply packed signed words and store low word.
fld5=SSE2

fld1=PMULUDQ
fld2=0F F4 /r
fld3=mm1,mm2/m64
fld4=Multiply packed unsigned dwords.
fld5=SSE2

fld1=PMULUDQ
fld2=66 OF F4 /r
fld3=xmm1,xmm2/m128
fld4=Multiply packed unsigned dwords.
fld5=SSE2

fld1=PMVGEZB
fld2=0F 5B /r
fld3=mm,m64
fld4=Packed move if greater-than-or-equal.
fld5=MMX,CYRIX

fld1=PMVLZB
fld2=0F 5A /r
fld3=mm,m64
fld4=Packed move if less-than.
fld5=MMX,CYRIX

fld1=PMVZB
fld2=0F 58 /r
fld3=mm,m64
fld4=Packed move if not-equal.
fld5=MMX,CYRIX

fld1=POP
fld2=0F
fld3=CS
fld4=Pop data to CS (only on some 8086s).
fld5=86,UNDOC

fld1=POP
fld2=1F
fld3=DS
fld4=Pop data to DS.
fld5=86

fld1=POP
fld2=58
fld3=eAX
fld4=Pop data to register.
fld5=86/386

fld1=POP
fld2=5D
fld3=eBP
fld4=Pop data to register.
fld5=86/386

fld1=POP
fld2=5B
fld3=eBX
fld4=Pop data to register.
fld5=86/386

fld1=POP
fld2=59
fld3=eCX
fld4=Pop data to register.
fld5=86/386

fld1=POP
fld2=5F
fld3=eDI
fld4=Pop data to register.
fld5=86/386

fld1=POP
fld2=5A
fld3=eDX
fld4=Pop data to register.
fld5=86/386

fld1=POP
fld2=07
fld3=ES
fld4=Pop data to ES.
fld5=86

fld1=POP
fld2=5E
fld3=eSI
fld4=Pop data to register.
fld5=86/386

fld1=POP
fld2=5C
fld3=eSP
fld4=Pop data to register.
fld5=86/386

fld1=POP
fld2=0F A1
fld3=FS
fld4=Pop data to FS.
fld5=386

fld1=POP
fld2=0F A9
fld3=GS
fld4=Pop data to GS.
fld5=386

fld1=POP
fld2=8F /0
fld3=r/m
fld4=Pop data to destination.
fld5=86,386

fld1=POP
fld2=17
fld3=SS
fld4=Pop data to SS.
fld5=SS

fld1=POPA/POPAD
fld2=61
fld3=n/a
fld4=Pop all General-purpose registers.
fld5=186/386

fld1=POPF/POPFD
fld2=9D
fld3=n/a
fld4=Pop CPU flags.
fld5=186/386

fld1=POR
fld2=0F EB /r
fld3=mm1,mm2/m64
fld4=Bitwise OR of MMX register.
fld5=MMX

fld1=POR
fld2=66 0F EB /r
fld3=xmm1,xmm2/m128
fld4=Bitwise OR of XMM register.
fld5=SSE2

fld1=PREFETCH
fld2=0F 0D /0
fld3=m8
fld4=Prefetch data into caches.
fld5=3DNOW

fld1=PREFETCHNTA
fld2=0F 18 /mem|0
fld3=m8
fld4=Prefetch non-temporal data into caches.
fld5=SSE,ATHLON

fld1=PREFETCHT0
fld2=0F 18 /mem|1
fld3=m8
fld4=Prefetch temporal data into caches.
fld5=SSE,ATHLON

fld1=PREFETCHT1
fld2=0F 18 /mem|2
fld3=m8
fld4=Prefetch temporal data into 1st level cache.
fld5=SSE,ATHLON

fld1=PREFETCHT2
fld2=0F 18 /mem|3
fld3=m8
fld4=Prefetch temporal data into 1st level cache.
fld5=SSE,ATHLON

fld1=PREFETCHW
fld2=0F 0D /1
fld3=m8
fld4=Prefetch data into caches.
fld5=3DNOW

fld1=PSADBW
fld2=0F F6 /r
fld3=mm1,mm2/m64
fld4=Compute sum of absolute differences.
fld5=SSE2

fld1=PSADBW
fld2=66 0F F6 /r
fld3=xmm1,xmm2/m128
fld4=Compute sum of absolute differences.
fld5=SSE2

fld1=PSHUFD
fld2=66 0F 70 /r ib
fld3=xmm1,xmm2/m128,imm8
fld4=Shuffle packed dwords.
fld5=SSE2

fld1=PSHUFHW
fld2=F3 0F 70 /r ib
fld3=xmm1,xmm2/m128,imm8
fld4=Shuffle packed high words.
fld5=SSE2

fld1=PSHUFLW
fld2=F2 0F 70 /r ib
fld3=xmm1,xmm2/m128,imm8
fld4=Shuffle packed low words.
fld5=SSE2

fld1=PSHUFW
fld2=0F 70 /r ib
fld3=mm1,mm2/m64,imm8
fld4=Shuffle packed words.
fld5=SSE

fld1=PSLLD
fld2=0F 72 /3|6 ib
fld3=mm,imm8
fld4=Left logical shift of packed dwords.
fld5=MMX

fld1=PSLLD
fld2=0F F2 /r
fld3=mm1,mm2/m64
fld4=Left logical shift of packed dwords.
fld5=MMX

fld1=PSLLD
fld2=66 0F 72 /3|6 ib
fld3=xmm,imm8
fld4=Left logical shift of packed dwords.
fld5=SSE2

fld1=PSLLD
fld2=66 0F F2 /r
fld3=xmm1,xmm2/m128
fld4=Left logical shift of packed dwords.
fld5=SSE2

fld1=PSLLDQ
fld2=66 0F 73 /3|7 ib
fld3=xmm1,imm8
fld4=Left logical shift of double qwords.
fld5=SSE2

fld1=PSLLQ
fld2=0F 73 /3|6 ib
fld3=mm,imm8
fld4=Left logical shift of packed qwords.
fld5=MMX

fld1=PSLLQ
fld2=0F F3 /r
fld3=mm1,mm2/m64
fld4=Left logical shift of packed qwords.
fld5=MMX

fld1=PSLLQ
fld2=66 0F 73 /3|6 ib
fld3=xmm,imm8
fld4=Left logical shift of packed qwords.
fld5=SSE2

fld1=PSLLQ
fld2=66 0F F3 /r
fld3=xmm1,xmm2/m128
fld4=Left logical shift of packed qwords.
fld5=SSE2

fld1=PSLLW
fld2=0F 71 /3|6 ib
fld3=mm,imm8
fld4=Left logical shift of packed words.
fld5=MMX

fld1=PSLLW
fld2=0F F1 /r
fld3=mm1,mm2/m64
fld4=Left logical shift of packed words.
fld5=MMX

fld1=PSLLW
fld2=66 0F 71 /3|6 ib
fld3=xmm,imm8
fld4=Left logical shift of packed words.
fld5=SSE2

fld1=PSLLW
fld2=66 0F F1 /r
fld3=xmm1,xmm2/m128
fld4=Left logical shift of packed words.
fld5=SSE2

fld1=PSRAD
fld2=0F 72 /3|4 ib
fld3=mm,imm8
fld4=Right arithmetic shift of packed dwords.
fld5=MMX

fld1=PSRAD
fld2=0F E2 /r
fld3=mm1,mm2/m64
fld4=Right arithmetic shift of packed dwords.
fld5=MMX

fld1=PSRAD
fld2=66 0F 72 /3|4 ib
fld3=xmm,imm8
fld4=Right arithmetic shift of packed dwords.
fld5=SSE2

fld1=PSRAD
fld2=66 0F E2 /r
fld3=xmm1, xmm2/m128
fld4=Right arithmetic shift of packed dwords.
fld5=SSE2

fld1=PSRAW
fld2=0F 71 /4 ib
fld3=mm,imm8
fld4=Right arithmetic shift of packed words.
fld5=MMX

fld1=PSRAW
fld2=0F E1 /r
fld3=mm1,mm2/m64
fld4=Right arithmetic shift of packed words.
fld5=MMX

fld1=PSRAW
fld2=66 0F 71 /4 ib
fld3=xmm,imm8
fld4=Right arithmetic shift of packed words.
fld5=SSE2

fld1=PSRAW
fld2=66 0F E1 /r
fld3=xmm1,xmm2/m128
fld4=Right arithmetic shift of packed words.
fld5=SSE2

fld1=PSRLD
fld2=0F 72 /3|2 ib
fld3=mm,imm8
fld4=Right logical shift of packed dwords.
fld5=MMX

fld1=PSRLD
fld2=0F D2 /r
fld3=mm1,mm2/m64
fld4=Right logical shift of packed dwords.
fld5=MMX

fld1=PSRLD
fld2=66 0F 72 /3|2 ib
fld3=xmm,imm8
fld4=Right logical shift of packed dwords.
fld5=SSE2

fld1=PSRLD
fld2=66 0F D2 /r
fld3=xmm1,xmm2/m128
fld4=Right logical shift of packed dwords.
fld5=SSE2

fld1=PSRLDQ
fld2=66 0F 73 /3|3 ib
fld3=xmm,imm8
fld4=Right logical shift of double qword.
fld5=SSE2

fld1=PSRLQ
fld2=0F 73 /2 ib
fld3=mm,imm8
fld4=Right logical shift of packed qwords.
fld5=MMX

fld1=PSRLQ
fld2=0F D3 /r
fld3=mm1,mm2/m64
fld4=Right logical shift of packed qwords.
fld5=MMX

fld1=PSRLQ
fld2=66 0F 73 /2 ib
fld3=xmm,imm8
fld4=Right logical shift of packed qwords.
fld5=SSE2

fld1=PSRLQ
fld2=66 0F D3 /r
fld3=xmm1,xmm2/m128
fld4=Right logical shift of packed qwords.
fld5=SSE2

fld1=PSRLW
fld2=0F 71 /3|2 ib
fld3=mm,imm8
fld4=Right logical shift of packed words.
fld5=MMX

fld1=PSRLW
fld2=0F D1 /r
fld3=mm1,mm2/m64
fld4=Right logical shift of packed words.
fld5=MMX

fld1=PSRLW
fld2=66 0F 71 /3|2 ib
fld3=xmm,imm8
fld4=Right logical shift of packed words.
fld5=SSE2

fld1=PSRLW
fld2=66 0F D1 /r
fld3=xmm1,xmm2/m128
fld4=Right logical shift of packed words.
fld5=SSE2

fld1=PSUBB
fld2=0F F8 /r
fld3=mm1,mm2/m64
fld4=Subtract packed byte integers.
fld5=MMX

fld1=PSUBB
fld2=66 0F F8 /r
fld3=xmm1,xmm2/m128
fld4=Subtract packed byte integers.
fld5=SSE2

fld1=PSUBD
fld2=0F FA /r
fld3=mm1,mm2/m64
fld4=Subtract packed dword integers.
fld5=MMX

fld1=PSUBD
fld2=66 0F FA /r
fld3=xmm1,xmm2/m128
fld4=Subtract packed dword integers.
fld5=SSE2

fld1=PSUBQ
fld2=0F FB /r
fld3=mm1,mm2/m64
fld4=Subtract packed qword integers.
fld5=MMX

fld1=PSUBQ
fld2=66 0F FB /r
fld3=xmm1,xmm2/m128
fld4=Subtract packed qword integers.
fld5=SSE2

fld1=PSUBSB
fld2=0F E8 /r
fld3=mm1,mm2/m64
fld4=Subtract packed signed byte integers.
fld5=MMX

fld1=PSUBSB
fld2=66 0F E8 /r
fld3=xmm1,xmm2/m128
fld4=Subtract packed signed byte integers.
fld5=SSE2

fld1=PSUBSIW
fld2=0F 55 /r
fld3=mm1,mm2/m64
fld4=Subtract packed words and store to implicit register.
fld5=MMX,CYRIX

fld1=PSUBSW
fld2=0F E9 /r
fld3=mm1,mm2/m64
fld4=Subtract packed signed word integers.
fld5=MMX

fld1=PSUBSW
fld2=66 0F E9 /r
fld3=xmm1,xmm2/m128
fld4=Subtract packed signed word integers.
fld5=SSE2

fld1=PSUBUSB
fld2=0F D8 /r
fld3=mm1,mm2/m64
fld4=Subtract packed unsigned byte integers.
fld5=MMX

fld1=PSUBUSB
fld2=66 0F D8 /r
fld3=xmm1,xmm2/m128
fld4=Subtract packed unsigned byte integers.
fld5=SSE2

fld1=PSUBUSW
fld2=0F D9 /r
fld3=mm1,mm2/m64
fld4=Subtract packed unsigned word integers.
fld5=MMX

fld1=PSUBUSW
fld2=66 0F D9 /r
fld3=xmm1,xmm2/m128
fld4=Subtract packed unsigned word integers.
fld5=SSE2

fld1=PSUBW
fld2=0F F9 /r
fld3=mm1,mm2/m64
fld4=Subtract packed word integers.
fld5=MMX

fld1=PSUBW
fld2=66 0F F9 /r
fld3=xmm1,xmm2/m128
fld4=Subtract packed word integers.
fld5=SSE2

fld1=PSWAPW/PSWAPD
fld2=0F 0F /r BB
fld3=mm1,mm2/m64
fld4=Swap packed data.
fld5=3DNOW

fld1=PUNPCKHBW
fld2=0F 68 /r
fld3=mm1,mm2/m64
fld4=Unpack and interleave high-order bytes.
fld5=MMX

fld1=PUNPCKHBW
fld2=66 0F 68 /r
fld3=xmm1,xmm2/m128
fld4=Unpack and interleave high-order bytes.
fld5=SSE2

fld1=PUNPCKHDQ
fld2=0F 6A /r
fld3=mm1,mm2/m64
fld4=Unpack and interleave high-order dwords.
fld5=MMX

fld1=PUNPCKHDQ
fld2=66 0F 6A /r
fld3=xmm1,xmm2/m128
fld4=Unpack and interleave high-order dwords.
fld5=SSE2

fld1=PUNPCKHQDQ
fld2=66 0F 6D /r
fld3=xmm1,xmm2/m128
fld4=Unpack and interleave high-order qwords.
fld5=SSE2

fld1=PUNPCKHWD
fld2=0F 69 /r
fld3=mm1,mm2/m64
fld4=Unpack and interleave high-order words.
fld5=MMX

fld1=PUNPCKHWD
fld2=66 0F 69 /r
fld3=xmm1,xmm2/m128
fld4=Unpack and interleave high-order words.
fld5=SSE2

fld1=PUNPCKLBW
fld2=0F 60 /r
fld3=mm1,mm2/m32
fld4=Unpack and interleave low-order bytes.
fld5=MMX

fld1=PUNPCKLBW
fld2=66 0F 60 /r
fld3=xmm1,xmm2/m128
fld4=Unpack and interleave low-order bytes.
fld5=SSE2

fld1=PUNPCKLDQ
fld2=0F 62 /r
fld3=mm1,mm2/m32
fld4=Unpack and interleave low-order dwords.
fld5=MMX

fld1=PUNPCKLDQ
fld2=66 0F 62 /r
fld3=xmm1,xmm2/m128
fld4=Unpack and interleave low-order dwords.
fld5=SSE2

fld1=PUNPCKLQDQ
fld2=66 0F 6C /r
fld3=xmm1,xmm2/m128
fld4=Unpack and interleave low-order qwords.
fld5=SSE2

fld1=PUNPCKLWD
fld2=0F 61 /r
fld3=mm1,mm2/m32
fld4=Unpack and interleave low-order words.
fld5=MMX

fld1=PUNPCKLWD
fld2=66 0F 61 /r
fld3=xmm1,xmm2/m128
fld4=Unpack and interleave low-order words.
fld5=SSE2

fld1=PUSH
fld2=0E
fld3=CS
fld4=Push CS onto the stack.
fld5=86

fld1=PUSH
fld2=1E
fld3=DS
fld4=Push DS onto the stack.
fld5=86

fld1=PUSH
fld2=50
fld3=eAX
fld4=Push register onto the stack.
fld5=86/386

fld1=PUSH
fld2=55
fld3=eBP
fld4=Push register onto the stack.
fld5=86/386

fld1=PUSH
fld2=53
fld3=eBX
fld4=Push register onto the stack.
fld5=86/386

fld1=PUSH
fld2=51
fld3=eCX
fld4=Push register onto the stack.
fld5=86/386

fld1=PUSH
fld2=57
fld3=eDI
fld4=Push register onto the stack.
fld5=86/386

fld1=PUSH
fld2=52
fld3=eDX
fld4=Push register onto the stack.
fld5=86/386

fld1=PUSH
fld2=06
fld3=ES
fld4=Push ES onto the stack.
fld5=86

fld1=PUSH
fld2=56
fld3=eSI
fld4=Push register onto the stack.
fld5=86/386

fld1=PUSH
fld2=54
fld3=eSP
fld4=Push register onto the stack.
fld5=86/386

fld1=PUSH
fld2=0F A0
fld3=FS
fld4=Push FS onto the stack.
fld5=386

fld1=PUSH
fld2=0F A8
fld3=GS
fld4=Push GS onto the stack.
fld5=386

fld1=PUSH
fld2=68
fld3=imm
fld4=Push immmediate word/dword onto the stack.
fld5=286

fld1=PUSH
fld2=6A
fld3=imm8
fld4=Push immmediate byte onto the stack.
fld5=286

fld1=PUSH
fld2=FF /6
fld3=r/m
fld4=Push source onto the stack.
fld5=86/386

fld1=PUSH
fld2=16
fld3=SS
fld4=Push SS onto the stack.
fld5=86

fld1=PUSHA/PUSHAD
fld2=60
fld3=n/a
fld4=Push all general-purpose registers.
fld5=186/386

fld1=PUSHF/PUSHFD
fld2=9C
fld3=n/a
fld4=Push CPU flags.
fld5=186/386

fld1=PXOR
fld2=0F EF /r
fld3=mm1,mm2/m64
fld4=Bitwise XOR of 64-bit MMX operands.
fld5=MMX

fld1=PXOR
fld2=66 0F EF /r
fld3=xmm1,xmm2/m128
fld4=Bitwise XOR of 128-bit MMX operands.
fld5=SSE3

fld1=RCL
fld2=D1 /2
fld3=r/m,1
fld4=Rotate left through carry bit.
fld5=86/386

fld1=RCL
fld2=D3 /2
fld3=r/m,CL
fld4=Rotate left through carry bit.
fld5=86/386

fld1=RCL
fld2=C1 /2 ib
fld3=r/m,imm8
fld4=Rotate left through carry bit.
fld5=286

fld1=RCL
fld2=D0 /2
fld3=r/m8,1
fld4=Rotate left through carry bit.
fld5=86

fld1=RCL
fld2=D2 /2
fld3=r/m8,CL
fld4=Rotate left through carry bit.
fld5=86

fld1=RCL
fld2=C0 /2 ib
fld3=r/m8,imm8
fld4=Rotate left through carry bit.
fld5=286

fld1=RCPPS
fld2=0F 53 /r
fld3=xmm1,xmm2/m128
fld4=Reciprocals of packed single-precision floats.
fld5=SSE

fld1=RCPSS
fld2=F3 0F 53 /r
fld3=xmm1,xmm2/m32
fld4=Reciprocal of scalar single-precision floats.
fld5=SSE

fld1=RCR
fld2=D1 /3
fld3=r/m,1
fld4=Rotate right through carry bit.
fld5=86/386

fld1=RCR
fld2=D3 /3
fld3=r/m,CL
fld4=Rotate right through carry bit.
fld5=86/386

fld1=RCR
fld2=C1 /3 ib
fld3=r/m,imm8
fld4=Rotate right through carry bit.
fld5=286

fld1=RCR
fld2=D0 /3
fld3=r/m8,1
fld4=Rotate right through carry bit.
fld5=86

fld1=RCR
fld2=D2 /3
fld3=r/m8,CL
fld4=Rotate right through carry bit.
fld5=86

fld1=RCR
fld2=C0 /3 ib
fld3=r/m8,imm8
fld4=Rotate right through carry bit.
fld5=286

fld1=RDMSR
fld2=0F 32
fld3=n/a
fld4=Read Model Specific Registers.
fld5=P5,PRIV

fld1=RDPMC
fld2=0F 33
fld3=n/a
fld4=Read performance-monitoring counters.
fld5=P6

fld1=RDSHR
fld2=0F 36 /0
fld3=r/m32
fld4=Read SMM header pointer register.
fld5=386,CYRIX,SMM

fld1=RDTSC
fld2=0F 31
fld3=n/a
fld4=Read time-stamp counter.
fld5=P5

fld1=REP/REPE/REPZ
fld2=F3
fld3=(Prefix)
fld4=Repeat while eCX<>0 and ZF=1.
fld5=86

fld1=REPNE/REPNZ
fld2=F2
fld3=(Prefix)
fld4=Repeat while eCX<>0 and ZF=0.
fld5=86

fld1=RET/RETN
fld2=C2 iw
fld3=imm16
fld4=A near return from subroutine or procedure and pop data.
fld5=86

fld1=RET/RETN
fld2=C3
fld3=n/a
fld4=A near return from subroutine or procedure.
fld5=86

fld1=RETF
fld2=CB
fld3=n/a
fld4=A far return from subroutine or procedure.
fld5=86

fld1=RETF
fld2=CA iw
fld3=imm16
fld4=A far return from subroutine or procedure.
fld5=86

fld1=ROL
fld2=D1 /0
fld3=r/m,1
fld4=Rotate left.
fld5=86,386

fld1=ROL
fld2=D3 /0
fld3=r/m,CL
fld4=Rotate left.
fld5=86,386

fld1=ROL
fld2=C1 /0  ib
fld3=r/m,imm8
fld4=Rotate left.
fld5=286

fld1=ROL
fld2=D0 /0
fld3=r/m8,1
fld4=Rotate left.
fld5=86

fld1=ROL
fld2=D2 /0
fld3=r/m8,CL
fld4=Rotate left.
fld5=86

fld1=ROL
fld2=C0 /0 ib
fld3=r/m8,imm8
fld4=Rotate left.
fld5=286

fld1=ROR
fld2=D1 /1
fld3=r/m,1
fld4=Rotate right.
fld5=86,386

fld1=ROR
fld2=D3 /1
fld3=r/m,CL
fld4=Rotate right.
fld5=86,386

fld1=ROR
fld2=C1 /1 ib
fld3=r/m,imm8
fld4=Rotate right.
fld5=286

fld1=ROR
fld2=D0 /1
fld3=r/m8,1
fld4=Rotate right.
fld5=86

fld1=ROR
fld2=D2 /1
fld3=r/m8,CL
fld4=Rotate right.
fld5=86

fld1=ROR
fld2=C0 /1 ib
fld3=r/m8,imm8
fld4=Rotate right.
fld5=286

fld1=RSDC
fld2=0F 79 /r
fld3=sreg,m80
fld4=Restore segment register and descriptor.
fld5=486,CYRIX,SMM

fld1=RSLDT
fld2=0F 7B /0
fld3=m80
fld4=Restore LDTR and descriptor.
fld5=486,CYRIX,SMM

fld1=RSM
fld2=0F AA
fld3=n/a
fld4=Resume from System Management Mode.
fld5=P5

fld1=RSQRTPS
fld2=0F 52 /r
fld3=xmm1,xmm2/m128
fld4=Reciprocals of square roots of packed single-precision floats. 
fld5=SSE

fld1=RSQRTSS
fld2=F3 0F 52 /r
fld3=xmm1,xmm2/m32
fld4=Reciprocal of square root of packed single-precision float.
fld5=SSE

fld1=RSTS
fld2=0F 7D /0
fld3=m80
fld4=Restore TSR and descriptor.
fld5=486,CYRIX,SMM

fld1=SAHF
fld2=9E
fld3=n/a
fld4=Store AH into CPU flags.
fld5=86

fld1=SAL
fld2=D1 /4
fld3=r/m,1
fld4=Left shift.
fld5=86/386

fld1=SAL
fld2=D3 /4
fld3=r/m,CL
fld4=Left shift.
fld5=86/386

fld1=SAL
fld2=C1 /4 ib
fld3=r/m,imm8
fld4=Left shift.
fld5=286

fld1=SAL
fld2=D0 /4
fld3=r/m8,1
fld4=Left shift.
fld5=86

fld1=SAL
fld2=D2 /4
fld3=r/m8,CL
fld4=Left shift.
fld5=86

fld1=SAL
fld2=C0 /4 ib
fld3=r/m8,imm8
fld4=Left shift.
fld5=286

fld1=SALC
fld2=D6
fld3=n/a
fld4=Set AL from the CF (only on 8086).
fld5=86,UNDOC

fld1=SAR
fld2=D1 /7
fld3=r/m,1
fld4=Arithmetic shift right.
fld5=86/386

fld1=SAR
fld2=D3 /7
fld3=r/m,CL
fld4=Arithmetic shift right.
fld5=86/386

fld1=SAR
fld2=C1 /7 ib
fld3=r/m,imm8
fld4=Arithmetic shift right.
fld5=286

fld1=SAR
fld2=D0 /7
fld3=r/m8,1
fld4=Arithmetic shift right.
fld5=86

fld1=SAR
fld2=D2 /7
fld3=r/m8,CL
fld4=Arithmetic shift right.
fld5=86

fld1=SAR
fld2=C0 /7 ib
fld3=r/m8,imm8
fld4=Arithmetic shift right.
fld5=286

fld1=SBB
fld2=1C ib
fld3=AL,imm8
fld4=Subtract two integers with borrow.
fld5=86

fld1=SBB
fld2=1D iv
fld3=eAX,imm
fld4=Subtract two integers with borrow.
fld5=86/386

fld1=SBB
fld2=81 /3 iw
fld3=r/m,imm
fld4=Subtract two integers with borrow.
fld5=86/386

fld1=SBB
fld2=83 /3 ib
fld3=r/m,imm8
fld4=Subtract two integers with borrow.
fld5=86/386

fld1=SBB
fld2=19 /r
fld3=r/m,reg
fld4=Subtract two integers with borrow.
fld5=86/386

fld1=SBB
fld2=80 /3 ib
fld3=r/m8,imm8
fld4=Subtract two integers with borrow.
fld5=86

fld1=SBB
fld2=82 /3 ib
fld3=r/m8,imm8
fld4=Subtract two integers with borrow.
fld5=86

fld1=SBB
fld2=18 /r
fld3=r/m8,reg8
fld4=Subtract two integers with borrow.
fld5=86

fld1=SBB
fld2=1B /r
fld3=reg32,r/m
fld4=Subtract two integers with borrow.
fld5=86/386

fld1=SBB
fld2=1A /r
fld3=reg8,r/m8
fld4=Subtract two integers with borrow.
fld5=86

fld1=SCASB
fld2=AE
fld3=n/a
fld4=Scan string byte.
fld5=86

fld1=SCASW/SCASD
fld2=AF
fld3=n/a
fld4=Scan string word/dword.
fld5=86/386

fld1=SETA/SETNBE
fld2=0F 97 /2
fld3=r/m8
fld4=Set byte if above (CF=0 and ZF=0).
fld5=386

fld1=SETAE/SETNB/SETNC
fld2=0F 93 /2
fld3=r/m8
fld4=Set byte if above or equal (CF=0).
fld5=386

fld1=SETB/SETC/SETNAE
fld2=0F 92 /2
fld3=r/m8
fld4=Set byte if below (CF=1).
fld5=386

fld1=SETBE/SETNA
fld2=0F 96 /2
fld3=r/m8
fld4=Set byte if below or equal (CF=1 or ZF=1).
fld5=386

fld1=SETE/SETZ
fld2=0F 94 /2
fld3=r/m8
fld4=Set byte if equal (ZF=1).
fld5=386

fld1=SETG/SETNLE
fld2=0F 9F /2
fld3=r/m8
fld4=Set byte if greater (ZF=0 and SF=OF).
fld5=386

fld1=SETGE/SETNL
fld2=0F 9D /2
fld3=r/m8
fld4=Set byte if greater or equal (SF=OF).
fld5=386

fld1=SETL/SETNGE
fld2=0F 9C /2
fld3=r/m8
fld4=Set byte if less (SF<>OF).
fld5=386

fld1=SETLE/SETNG
fld2=0F 9E /2
fld3=r/m8
fld4=Set byte if less or equal (ZF=1 or SF<>OF).
fld5=386

fld1=SETNE/SETNZ
fld2=0F 95 /2
fld3=r/m8
fld4=Set byte if not equal (ZF=0).
fld5=386

fld1=SETNO
fld2=0F 91 /2
fld3=r/m8
fld4=Set byte if not overflow (OF=0).
fld5=386

fld1=SETNP/SETPO
fld2=0F 9B /2
fld3=r/m8
fld4=Set byte if parity odd (PF=0).
fld5=386

fld1=SETNS
fld2=0F 99 /2
fld3=r/m8
fld4=Set byte if not sign (SF=0).
fld5=386

fld1=SETO
fld2=0F 90 /2
fld3=r/m8
fld4=Set byte if overflow (OF=1).
fld5=386

fld1=SETP/SETPE
fld2=0F 9A /2
fld3=r/m8
fld4=Set byte if parity even (PF=1).
fld5=386

fld1=SETS
fld2=0F 98 /2
fld3=r/m8
fld4=Set byte if sign (SF=1).
fld5=386

fld1=SFENCE
fld2=0F AE /3|7
fld3=n/a
fld4=Store fence.
fld5=SSE

fld1=SGDT
fld2=0F 01 /0
fld3=mem
fld4=Store GDTR into memory.
fld5=286

fld1=SHL
fld2=D1 /4
fld3=r/m,1
fld4=Logical left shift.
fld5=86/386

fld1=SHL
fld2=D3 /4
fld3=r/m,CL
fld4=Logical left shift.
fld5=86/386

fld1=SHL
fld2=C1 /4 ib
fld3=r/m,imm8
fld4=Logical left shift.
fld5=286

fld1=SHL
fld2=D0 /4
fld3=r/m8,1
fld4=Logical left shift.
fld5=86

fld1=SHL
fld2=D2 /4
fld3=r/m8,CL
fld4=Logical left shift.
fld5=86

fld1=SHL
fld2=C0 /4 ib
fld3=r/m8,imm8
fld4=Logical left shift.
fld5=286

fld1=SHLD
fld2=0F A5
fld3=r/m,reg,CL
fld4=Double precision left shift.
fld5=386

fld1=SHLD
fld2=0F A4
fld3=r/m,reg,imm8
fld4=Double precision left shift.
fld5=386

fld1=SHR
fld2=D1 /5
fld3=r/m,1
fld4=Logical right shift.
fld5=86/386

fld1=SHR
fld2=D3 /5
fld3=r/m,CL
fld4=Logical right shift.
fld5=86,386

fld1=SHR
fld2=C1 /5 ib
fld3=r/m,imm8
fld4=Logical right shift.
fld5=286

fld1=SHR
fld2=D0 /5
fld3=r/m8,1
fld4=Logical right shift.
fld5=86

fld1=SHR
fld2=D2 /5
fld3=r/m8,CL
fld4=Logical right shift.
fld5=86

fld1=SHR
fld2=C0 /5 ib
fld3=r/m8,imm8
fld4=Logical right shift.
fld5=286

fld1=SHRD
fld2=0F AD /r
fld3=r/m,reg,CL
fld4=Double precision right shift.
fld5=386

fld1=SHRD
fld2=0F AC /r ib
fld3=r/m,reg,imm8
fld4=Double precision right shift.
fld5=386

fld1=SHUFPD
fld2=66 0F C6 /r ib
fld3=xmm1,xmm2/m128,imm8
fld4=Shuffle packed double-precision floats.
fld5=SSE2

fld1=SHUFPS
fld2=0F C6 /r ib
fld3=xmm1,xmm2/m128,imm8
fld4=Shuffle packed single-precision floats.
fld5=SSE

fld1=SIDT
fld2=0F 01 /1
fld3=mem
fld4=Store IDTR into memory.
fld5=286

fld1=SLDT
fld2=0F 00 /0
fld3=r/m16
fld4=Store LDTR into memory.
fld5=286

fld1=SMI
fld2=F1
fld3=n/a
fld4=System Management Interrupt (on some AMD 386/486s).
fld5=386,AMD,UNDOC

fld1=SMINT
fld2=0F 38
fld3=n/a
fld4=Put processor into SMM mode.
fld5=P5,CYRIX

fld1=SMINTOLD
fld2=0F 7E
fld3=n/a
fld4=Put processor into SMM mode (only 486).
fld5=486,CYRIX

fld1=SMSW
fld2=0F 01 /4
fld3=r/m16
fld4=Store MSW (the bottom half of CR0) into memory.
fld5=286

fld1=SQRTPD
fld2=66 0F 51 /r
fld3=xmm1,xmm2/m128
fld4=Square roots of packed double-precision floats.
fld5=SSE2

fld1=SQRTPS
fld2=0F 51 /r
fld3=xmm1,xmm2/m128
fld4=Square roots of packed single-precision floats.
fld5=SSE

fld1=SQRTSD
fld2=F2 0F 51 /r
fld3=xmm1,xmm2/m64
fld4=Square roots of scalar double-precision floats.
fld5=SSE2

fld1=SQRTSS
fld2=F3 0F 51 /r
fld3=xmm1,xmm2/m32
fld4=Square roots of scalar single-precision floats.
fld5=SSE

fld1=STC
fld2=F9
fld3=n/a
fld4=Set the CF flag.
fld5=86

fld1=STD
fld2=FD
fld3=n/a
fld4=Set the DF flag.
fld5=86

fld1=STI
fld2=FB
fld3=n/a
fld4=Set the IF flag (enable interrupts).
fld5=86

fld1=STMXCSR
fld2=0F AE /mem|3
fld3=m32
fld4=Store MXCSR state.
fld5=SSE

fld1=STOSB
fld2=AA
fld3=n/a
fld4=Store byte to string.
fld5=86

fld1=STOSW/STOSD
fld2=AB
fld3=n/a
fld4=Store word/dword to string.
fld5=86/386

fld1=STR
fld2=0F 00 /1
fld3=r/m16
fld4=Store TR into memory.
fld5=286

fld1=SUB
fld2=2C ib
fld3=AL,imm8
fld4=Subtract two integers.
fld5=86

fld1=SUB
fld2=2D iv
fld3=eAX,imm
fld4=Subtract two integers.
fld5=86/386

fld1=SUB
fld2=81 /5 iv
fld3=r/m,imm
fld4=Subtract two integers.
fld5=86/386

fld1=SUB
fld2=83 /5 ib
fld3=r/m,imm8
fld4=Subtract two integers.
fld5=86/386

fld1=SUB
fld2=29 /r
fld3=r/m,reg
fld4=Subtract two integers.
fld5=86/386

fld1=SUB
fld2=80 /5 ib
fld3=r/m8,imm8
fld4=Subtract two integers.
fld5=86

fld1=SUB
fld2=82 /5 ib
fld3=r/m8,imm8
fld4=Subtract two integers.
fld5=86

fld1=SUB
fld2=28 /r
fld3=r/m8,reg8
fld4=Subtract two integers.
fld5=86

fld1=SUB
fld2=2B /r
fld3=reg,r/m
fld4=Subtract two integers.
fld5=86/386

fld1=SUB
fld2=2A /r
fld3=reg8,r/m8
fld4=Subtract two integers.
fld5=86

fld1=SUBPD
fld2=66 0F 5C /r
fld3=xmm1,xmm2/m128
fld4=Subtract packed double-precision floats.
fld5=SSE2

fld1=SUBPS
fld2=0F 5C /r
fld3=xmm1,xmm2/m128
fld4=Subtract packed single-precision floats.
fld5=SSE

fld1=SUBSD
fld2=F2 0F 5C /r
fld3=xmm1,xmm2/m128
fld4=Subtract scalar double-precision floats.
fld5=SSE2

fld1=SUBSS
fld2=F3 0F 5C /r
fld3=xmm1,xmm2/m128
fld4=Subtract scalar single-precision floats.
fld5=SSE

fld1=SVDC
fld2=0F 78 /r
fld3=sreg,m80
fld4=Save segment register and descriptor.
fld5=486,CYRIX,SMM

fld1=SVLDT
fld2=0F 7A /0
fld3=m80
fld4=Save LDTR and descriptor.
fld5=486,CYRIX,SMM

fld1=SVTS
fld2=0F 7C /0
fld3=m80
fld4=Save TSR and descriptor.
fld5=486,CYRIX,SMM

fld1=SYSCALL
fld2=0F 05
fld3=n/a
fld4=Call operating system.
fld5=P6,AMD

fld1=SYSENTER
fld2=0F 34
fld3=n/a
fld4=Fast system call.
fld5=P6

fld1=SYSEXIT
fld2=0F 35
fld3=n/a
fld4=Fast return from fast system call.
fld5=P6,PRIV

fld1=SYSRET
fld2=0F 07
fld3=n/a
fld4=Return from operating system.
fld5=P6,AMD,PRIV

fld1=TEST
fld2=A8 ib
fld3=AL,imm8
fld4=Bitwise test of two integers.
fld5=86

fld1=TEST
fld2=A9 iv
fld3=eAX,imm
fld4=Bitwise test of two integers.
fld5=86/386

fld1=TEST
fld2=F7 /0 iv
fld3=r/m,imm
fld4=Bitwise test of two integers.
fld5=86/386

fld1=TEST
fld2=85 /r
fld3=r/m,reg
fld4=Bitwise test of two integers.
fld5=86/386

fld1=TEST
fld2=F6 /0 ib
fld3=r/m8,imm8
fld4=Bitwise test of two integers.
fld5=86

fld1=TEST
fld2=84 /r
fld3=r/m8,reg8
fld4=Bitwise test of two integers.
fld5=86

fld1=UCOMISD
fld2=66 0F 2E /r
fld3=xmm1,xmm2/m128
fld4=Unordered compare scalar double-precision floats.
fld5=SSE2

fld1=UCOMISS
fld2=0F 2E /r
fld3=xmm1,xmm2/m128
fld4=Unordered compare scalar double-precision floats.
fld5=SSE

fld1=UD0
fld2=0F FF
fld3=n/a
fld4=Used by AMD for an invalid opcode exception.
fld5=186,UNDOC

fld1=UD1
fld2=0F B9
fld3=n/a
fld4=Used by Intel for an invalid opcode exception.
fld5=186,UNDOC

fld1=UD2
fld2=0F 0B
fld3=n/a
fld4=Undefined instruction (for invalid opcode exception).
fld5=186

fld1=UMOV
fld2=0F 11 /r
fld3=r/m,reg
fld4=Move user data (on some AMD and IBM 386/486s).
fld5=386,AMD,UNDOC

fld1=UMOV
fld2=0F 10 /r
fld3=r/m8,reg8
fld4=Move user data (on some AMD and IBM 386/486s).
fld5=386,AMD,UNDOC

fld1=UMOV
fld2=0F 13 /r
fld3=reg,r/m
fld4=Move user data (on some AMD and IBM 386/486s).
fld5=386,AMD,UNDOC

fld1=UMOV
fld2=0F 12 /r
fld3=reg8,r/m8
fld4=Move user data (on some AMD and IBM 386/486s).
fld5=386,AMD,UNDOC

fld1=UNPCKHPD
fld2=66 0F 15 /r
fld3=xmm1,xmm2/m128
fld4=Interleaved unpack of high packed double-precision floats.
fld5=SSE2

fld1=UNPCKHPS
fld2=0F 15 /r
fld3=xmm1,xmm2/m128
fld4=Interleaved unpack of high packed single-precision floats.
fld5=SSE

fld1=UNPCKLPD
fld2=66 0F 14 /r
fld3=xmm1,xmm2/m128
fld4=Interleaved unpack of low packed double-precision floats.
fld5=SSE2

fld1=UNPCKLPS
fld2=0F 14 /r
fld3=xmm1,xmm2/m128
fld4=Interleaved unpack of low packed single-precision floats.
fld5=SSE

fld1=VERR
fld2=0F 00 /4
fld3=r/m16
fld4=Verify a segment for reading.
fld5=286

fld1=VERW
fld2=0F 00 /5
fld3=r/m16
fld4=Verify a segment for writing.
fld5=286

fld1=WAIT/FWAIT
fld2=9B
fld3=n/a
fld4=Wait until all pending FPU exceptions have happened.
fld5=86

fld1=WBINVD
fld2=0F 09
fld3=n/a
fld4=Write back and invalidate cache.
fld5=486,PRIV

fld1=WRMSR
fld2=0F 30
fld3=n/a
fld4=Write model-specific register.
fld5=P5,PRIV

fld1=WRSHR
fld2=0F 37 /0
fld3=r/m32
fld4=Read SMM header pointer register.
fld5=386,CYRIX,SMM

fld1=XADD
fld2=0F C1 /r
fld3=r/m,reg
fld4=Exchange and add.
fld5=486

fld1=XADD
fld2=0F C0 /r
fld3=r/m8,reg8
fld4=Exchange and add.
fld5=486

fld1=XBTS
fld2=0F A6 /r
fld3=reg,r/m
fld4=Write bits from r/m to reg (only on the old 386s).
fld5=386,UNDOC

fld1=XCHG
fld2=95
fld3=eAX,eBP or reverse
fld4=Exchange contents of two registers.
fld5=86/386

fld1=XCHG
fld2=93
fld3=eAX,eBX or reverse
fld4=Exchange contents of two registers.
fld5=86/386

fld1=XCHG
fld2=91
fld3=eAX,eCX or reverse
fld4=Exchange contents of two registers.
fld5=86/386

fld1=XCHG
fld2=97
fld3=eAX,eDI or reverse
fld4=Exchange contents of two registers.
fld5=86/386

fld1=XCHG
fld2=92
fld3=eAX,eDX or reverse
fld4=Exchange contents of two registers.
fld5=86/386

fld1=XCHG
fld2=96
fld3=eAX,eSI or reverse
fld4=Exchange contents of two registers.
fld5=86/386

fld1=XCHG
fld2=94
fld3=eAX,eSP or reverse
fld4=Exchange contents of two registers.
fld5=86/386

fld1=XCHG
fld2=87 /r
fld3=r/m,reg or reverse
fld4=Exchange contents of two operands.
fld5=86/386

fld1=XCHG
fld2=86 /r
fld3=r/m8,reg8 or reverse
fld4=Exchange contents of two operands.
fld5=86

fld1=XLAT/XLATB
fld2=D7
fld3=n/a
fld4=Move byte from [eBX+AL] into AL.
fld5=86

fld1=XOR
fld2=34 ib
fld3=AL,imm8
fld4=Bitwise XOR of two registers.
fld5=86

fld1=XOR
fld2=35 iv
fld3=eAX,imm
fld4=Bitwise XOR of two registers.
fld5=86,386

fld1=XOR
fld2=81 /6 iw
fld3=r/m,imm
fld4=Bitwise XOR of two registers.
fld5=86,386

fld1=XOR
fld2=83 /6 ib
fld3=r/m,imm8
fld4=Bitwise XOR of two registers.
fld5=86,386

fld1=XOR
fld2=31 /r
fld3=r/m,reg
fld4=Bitwise XOR of two registers.
fld5=86,386

fld1=XOR
fld2=80 /6 ib
fld3=r/m8,imm8
fld4=Bitwise XOR of two registers.
fld5=86

fld1=XOR
fld2=82 /6 ib
fld3=r/m8,imm8
fld4=Bitwise XOR of two registers.
fld5=86

fld1=XOR
fld2=30 /r
fld3=r/m8,reg8
fld4=Bitwise XOR of two registers.
fld5=86

fld1=XOR
fld2=33 /r
fld3=reg,r/m
fld4=Bitwise XOR of two registers.
fld5=86,386

fld1=XOR
fld2=32 /r
fld3=reg8,r/m8
fld4=Bitwise XOR of two registers.
fld5=86

fld1=XORPD
fld2=66 0F 57 /r
fld3=xmm1,xmm2/m128
fld4=Bitwise XOR of double-precision floats.
fld5=SSE2

fld1=XORPS
fld2=0F 57 /r
fld3=xmm1,xmm2/m128
fld4=Bitwise XOR of single-precision floats.
fld5=SSE
