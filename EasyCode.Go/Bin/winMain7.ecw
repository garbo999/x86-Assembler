;Do not modify this file!!!
Easy Code
Begin Window = winMain
  AlignMode       = 0
  AutoRedraw      = 0
  BackColor       = 0x8000000F
  Border          = 3
  Caption         = 1
  CenterWindow    = 3
  ClientEdge      = 0
  ClipChildren    = 1
  ClipSiblings    = 1
  ContextHelp     = 0
  ControlMenu     = 1
  CursorIcon      = [None]
  CursorShape     = 0
  DisableClose    = 0
  DrawingStyle    = 0
  DrawingWidth    = 1
  Enabled         = 1
  ExStyle         = 0x00040100
  Font            = MS Sans Serif,8,400,0,0,0
  ForeColor       = 0x80000012
  Height          = 8475
  IconBig         = [None]
  IconSmall       = [None]
  ImageType       = -1
  KeepSize        = 0
  KeyPreview      = 0
  Left            = 0
  MaximizeBox     = 1
  MDIChild        = 0
  Menu            = 0
  MinimizeBox     = 1
  NormalStyle     = 0x56EF0000
  Picture         = [None]
  RightToLeft     = 0
  ScaleMode       = 1
  ScrollBars      = 2
  ShowMode        = 0
  Style           = 0
  Text            = Project Euler in Assembler
  TimerInterval   = 0
  ToolTip         = 0
  ToolWindow      = 0
  Top             = 0
  Visible         = 1
  Width           = 10140
  Begin Button = btn31
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1031
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 6330
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 31
    TabStop         = 1
    Text            = xx6
    ToolTipText     = 
    Top             = 3885
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn30
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1030
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 6330
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 30
    TabStop         = 1
    Text            = xx5
    ToolTipText     = 
    Top             = 3150
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn29
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1029
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 6330
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 29
    TabStop         = 1
    Text            = xx4
    ToolTipText     = 
    Top             = 2430
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn28
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1028
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 6330
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 28
    TabStop         = 1
    Text            = xx3
    ToolTipText     = 
    Top             = 1710
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn27
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1027
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 6330
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 27
    TabStop         = 1
    Text            = Problem 23
    ToolTipText     = 
    Top             = 960
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn26
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1026
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 6330
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 26
    TabStop         = 1
    Text            = Problem 21
    ToolTipText     = 
    Top             = 255
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn25
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1025
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 5070
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 25
    TabStop         = 1
    Text            = Problem 18
    ToolTipText     = 
    Top             = 3825
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn24
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1024
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 5070
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 24
    TabStop         = 1
    Text            = Problem 15
    ToolTipText     = 
    Top             = 3120
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn23
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1023
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 5070
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 23
    TabStop         = 1
    Text            = Problem 12
    ToolTipText     = 
    Top             = 2460
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn22
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1022
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 5070
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 22
    TabStop         = 1
    Text            = Problem 13
    ToolTipText     = 
    Top             = 1755
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn21
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1021
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 5070
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 21
    TabStop         = 1
    Text            = Problem 11
    ToolTipText     = 
    Top             = 990
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn20
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1020
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 5070
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 20
    TabStop         = 1
    Text            = Problem 14
    ToolTipText     = 
    Top             = 225
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn19
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1019
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 3345
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 19
    TabStop         = 1
    Text            = Problem 17
    ToolTipText     = 
    Top             = 3885
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn18
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1018
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 3345
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 18
    TabStop         = 1
    Text            = Problem 25
    ToolTipText     = 
    Top             = 3165
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn17
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1017
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 3345
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 17
    TabStop         = 1
    Text            = Problem 16
    ToolTipText     = 
    Top             = 2520
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn16
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1016
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 3345
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 16
    TabStop         = 1
    Text            = Problem 20
    ToolTipText     = 
    Top             = 1740
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn15
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1015
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 615
    ImageType       = -1
    Left            = 3345
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 15
    TabStop         = 1
    Text            = Problem 19
    ToolTipText     = 
    Top             = 975
    Visible         = 1
    Width           = 1095
  End
  Begin Edit = edit1
    AutoHScroll     = 1
    AutoVScroll     = 0
    BackColor       = 0x80000005
    Border          = 1
    CaseStyle       = 0
    ClientEdge      = 1
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    DragAndDrop     = 1014
    Enabled         = 1
    ExStyle         = 0x00000200
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000008
    Height          = 3090
    Left            = 285
    MaxLength       = 0
    MultiLine       = 1
    NormalStyle     = 0x54300004
    PasswordChar    = 
    ReadOnly        = 0
    RightToLeft     = 0
    ScrollBars      = 3
    StaticEdge      = 0
    TabOrder        = 14
    TabStop         = 1
    Text            = Edit1
    TextAlignment   = 0
    ToolTipText     = 
    Top             = 4545
    Visible         = 1
    WantReturn      = 0
    Width           = 9180
  End
  Begin Button = btn14
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1013
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 3345
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 13
    TabStop         = 1
    Text            = Problem 22
    ToolTipText     = 
    Top             = 225
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn13
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1012
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 285
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 12
    TabStop         = 1
    Text            = Problem 4
    ToolTipText     = 
    Top             = 3090
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn12
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1011
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 1845
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 11
    TabStop         = 1
    Text            = Problem 8
    ToolTipText     = 
    Top             = 2355
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn10
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1010
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 1845
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 10
    TabStop         = 1
    Text            = Problem 9
    ToolTipText     = 
    Top             = 3075
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn11
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1009
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 1845
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 9
    TabStop         = 1
    Text            = Problem 6
    ToolTipText     = 
    Top             = 255
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn9
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1008
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 285
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 8
    TabStop         = 1
    Text            = Problem 5
    ToolTipText     = 
    Top             = 3840
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn8
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1007
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 285
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 7
    TabStop         = 1
    Text            = Problem 3 (64-bit)
    ToolTipText     = 
    Top             = 2385
    Visible         = 1
    Width           = 1320
  End
  Begin Button = btn7
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1006
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 285
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 6
    TabStop         = 1
    Text            = Problem 3 (32-bit)
    ToolTipText     = 
    Top             = 1710
    Visible         = 1
    Width           = 1380
  End
  Begin Button = btn6
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1005
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 1845
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 5
    TabStop         = 1
    Text            = Problem 10 (7v3)
    ToolTipText     = 
    Top             = 3780
    Visible         = 1
    Width           = 1305
  End
  Begin Button = btn5
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1004
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 1845
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 4
    TabStop         = 1
    Text            = Problem 7v2
    ToolTipText     = 
    Top             = 1710
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn3
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1003
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 1845
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 3
    TabStop         = 1
    Text            = Problem 7v1
    ToolTipText     = 
    Top             = 960
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn4
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1002
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 8490
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 2
    TabStop         = 1
    Text            = Test area
    ToolTipText     = 
    Top             = 1425
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn2
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1001
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 285
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 1
    TabStop         = 1
    Text            = Problem 2
    ToolTipText     = 
    Top             = 990
    Visible         = 1
    Width           = 1080
  End
  Begin Button = btn1
    BackColor       = 0x8000000F
    Border          = 0
    Cancel          = 0
    ClientEdge      = 0
    ClipSiblings    = 1
    CursorIcon      = [None]
    CursorShape     = 0
    Default         = 0
    DragAndDrop     = 1000
    DrawFocus       = 1
    Enabled         = 1
    ExStyle         = 0x00000000
    Font            = MS Sans Serif,8,400,0,0,0
    ForeColor       = 0x80000012
    Height          = 540
    ImageType       = -1
    Left            = 285
    MultiLine       = 0
    OwnerDraw       = 0
    NormalStyle     = 0x54000300
    Picture         = [None]
    PicturePosition = 0
    RightToLeft     = 0
    StaticEdge      = 0
    TabOrder        = 0
    TabStop         = 1
    Text            = Problem 1
    ToolTipText     = 
    Top             = 270
    Visible         = 1
    Width           = 1080
  End
End

.Const

; Problem 22 constant
;MEMSIZE				DD 0B600H ; unused
MAXSIZE Equ 260

.Data

WINMAIN_MESSAGES	DD WM_CREATE, OnwinMainCreate
					DD WM_CLOSE, OnwinMainClose
					DD WM_COMMAND, OnwinMainClickBtn

; General variables
myStringVar			DB 20 Dup 0
myStringVar2		DB 101H Dup 0
myStringVar3		DB 101H Dup 0
myDD1				DD 0
myDD2				DD 0
intArray		    DD 1111H, 22H, 33H, 44H, 55H, 66H, 77H, 88H, 99H, 0AAH  ; 10 dwords for integers
sqrtTest			DD 100
time1				SYSTEMTIME
time2				SYSTEMTIME
timeFT1				FILETIME
timeFT2				FILETIME
clientTime			DB 30 Dup 0
iterCounter1		DD 0			; used to analyze number of iterations to determine primes
iterCounter2		DD 0
fpu_controlword_1	DB 0	; error? should be DW ???
fpu_controlword_2	DB 0
bigNumber2			DQ 0

; file variables
fileName				DB 100H Dup 0
lpFileName				DD 0
dwDesiredAccess			DD GENERIC_WRITE
dwShareMode				DD 0
securityAttributes		SECURITY_ATTRIBUTES
lpSecurityAttributes	DD NULL ; If lpSecurityAttributes is NULL, the handle cannot be inherited.
dwCreationDistribution	DD CREATE_NEW
dwFlagsAndAttributes	DD FILE_ATTRIBUTE_NORMAL
hTemplateFile			DD 0

hFile					DD 0
fileBuffer				DB 100H Dup 0
;numberOfBytesRead		DD 0 ; already declared elsewhere
nIn						DD 0
nOut 					DD 0

; EULER problem 1

; EULER problem 2
fib1				DD 1
fib2				DD 2

; EULER problem 3
numberToFactor		DD 0			; defined in routine (32-bit unsigned integer)
primeFactorArray	DD 100 Dup 0	; accumulate results here since stack won't work with recursion

; EULER problem 3, 64-bit version
numberToFactor_64	DQ 0			; defined in routine (64-bit unsigned integer)

; EULER problem 4
maxPalindrome		DD 0

; EULER problem 6
sumOfSquares		DD 0			;
squareOfSum			DD 0			;

; EULER problem 7
candidate			DD 5			; First candidate to check = 5
primeCount			DD 2			; Two primes already known = 2 and 3
primeFlag			DD TRUE			; Flag for use in detecting primes
knownPrimes			DD 170000 Dup 0F00FH	; Space for array of known primes (size is needed for Problem 10, fill pattern is just for debugging and is not essential)
primeLimit1			DD 10001		; Number of primes to calculate (variable counter)
primeLimit2			DD 160001		; Number of primes to calculate (variable counter)
;primeLimitConstant	DD 10001		; Number of primes to calculate (constant, normally 10001)
candidateDividedByTwo	DD 0		;
candidateSquareRoot		DD 0		;

; EULER problem 8
problem8DataBlock DATABLOCK_BEGIN      ;comment
73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450
DATABLOCK_END

problem8MaxProduct				DD 0		; also using this as marker for end of data!

; EULER problem 9
arrayOfSquares 		DD 1000 Dup 0
asq					DD 0			; candidate value of asq
a					DD 0			; candidate value of a ("not squared")

; EULER problem 10
bigNumber	DD 0				; Low-order dword (bigNum is a 64-bit number)
			DD 0				; High-order dword

; EULER problem 11
problem11DataBlock DATABLOCK_BEGIN      ;comment
08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
DATABLOCK_END

problem11MaxProduct		DD 0	; also use this as marker for end of data!
numberArray				DD 400 Dup 0
rowFactor				DD 0
colFactor				DD 0
numProductsChecked		DD 0

maxRow1					DD 0
maxRow2					DD 0
maxRow3					DD 0
maxRow4					DD 0
maxCol1					DD 0
maxCol2					DD 0
maxCol3					DD 0
maxCol4					DD 0

; EULER problem 13

bigNum4			DD 40H Dup 0
bigNum5			DD 40H Dup 0
bigNum6			DD 40H Dup 0

problem13DataBlock DATABLOCK_BEGIN
37107287533902102798797998220837590246510135740250
46376937677490009712648124896970078050417018260538
74324986199524741059474233309513058123726617309629
91942213363574161572522430563301811072406154908250
23067588207539346171171980310421047513778063246676
89261670696623633820136378418383684178734361726757
28112879812849979408065481931592621691275889832738
44274228917432520321923589422876796487670272189318
47451445736001306439091167216856844588711603153276
70386486105843025439939619828917593665686757934951
62176457141856560629502157223196586755079324193331
64906352462741904929101432445813822663347944758178
92575867718337217661963751590579239728245598838407
58203565325359399008402633568948830189458628227828
80181199384826282014278194139940567587151170094390
35398664372827112653829987240784473053190104293586
86515506006295864861532075273371959191420517255829
71693888707715466499115593487603532921714970056938
54370070576826684624621495650076471787294438377604
53282654108756828443191190634694037855217779295145
36123272525000296071075082563815656710885258350721
45876576172410976447339110607218265236877223636045
17423706905851860660448207621209813287860733969412
81142660418086830619328460811191061556940512689692
51934325451728388641918047049293215058642563049483
62467221648435076201727918039944693004732956340691
15732444386908125794514089057706229429197107928209
55037687525678773091862540744969844508330393682126
18336384825330154686196124348767681297534375946515
80386287592878490201521685554828717201219257766954
78182833757993103614740356856449095527097864797581
16726320100436897842553539920931837441497806860984
48403098129077791799088218795327364475675590848030
87086987551392711854517078544161852424320693150332
59959406895756536782107074926966537676326235447210
69793950679652694742597709739166693763042633987085
41052684708299085211399427365734116182760315001271
65378607361501080857009149939512557028198746004375
35829035317434717326932123578154982629742552737307
94953759765105305946966067683156574377167401875275
88902802571733229619176668713819931811048770190271
25267680276078003013678680992525463401061632866526
36270218540497705585629946580636237993140746255962
24074486908231174977792365466257246923322810917141
91430288197103288597806669760892938638285025333403
34413065578016127815921815005561868836468420090470
23053081172816430487623791969842487255036638784583
11487696932154902810424020138335124462181441773470
63783299490636259666498587618221225225512486764533
67720186971698544312419572409913959008952310058822
95548255300263520781532296796249481641953868218774
76085327132285723110424803456124867697064507995236
37774242535411291684276865538926205024910326572967
23701913275725675285653248258265463092207058596522
29798860272258331913126375147341994889534765745501
18495701454879288984856827726077713721403798879715
38298203783031473527721580348144513491373226651381
34829543829199918180278916522431027392251122869539
40957953066405232632538044100059654939159879593635
29746152185502371307642255121183693803580388584903
41698116222072977186158236678424689157993532961922
62467957194401269043877107275048102390895523597457
23189706772547915061505504953922979530901129967519
86188088225875314529584099251203829009407770775672
11306739708304724483816533873502340845647058077308
82959174767140363198008187129011875491310547126581
97623331044818386269515456334926366572897563400500
42846280183517070527831839425882145521227251250327
55121603546981200581762165212827652751691296897789
32238195734329339946437501907836945765883352399886
75506164965184775180738168837861091527357929701337
62177842752192623401942399639168044983993173312731
32924185707147349566916674687634660915035914677504
99518671430235219628894890102423325116913619626622
73267460800591547471830798392868535206946944540724
76841822524674417161514036427982273348055556214818
97142617910342598647204516893989422179826088076852
87783646182799346313767754307809363333018982642090
10848802521674670883215120185883543223812876952786
71329612474782464538636993009049310363619763878039
62184073572399794223406235393808339651327408011116
66627891981488087797941876876144230030984490851411
60661826293682836764744779239180335110989069790714
85786944089552990653640447425576083659976645795096
66024396409905389607120198219976047599490197230297
64913982680032973156037120041377903785566085089252
16730939319872750275468906903707539413042652315011
94809377245048795150954100921645863754710598436791
78639167021187492431995700641917969777599028300699
15368713711936614952811305876380278410754449733078
40789923115535562561142322423255033685442488917353
44889911501440648020369068063960672322193204149535
41503128880339536053299340368006977710650566631954
81234880673210146739058568557934581403627822703280
82616570773948327592232845941706525094512325230608
22918802058777319719839450180888072429661980811197
77158542502016545090413245809786882778948721859617
72107838435069186155435662884062257473692284509516
20849603980134001723930671666823555245252804609722
53503534226472524250874054075591789781264330331690
DATABLOCK_END


; EULER problem 14
startingNumber		DD 0
maxStartingNumber	DD 0
maxChainLength		DD 0

; EULER problem 18
problem18DataBlock DATABLOCK_BEGIN
59
73 41
52 40 09
26 53 06 34
10 51 87 86 81
61 95 66 57 25 68
90 81 80 38 92 67 73
30 28 51 76 81 18 75 44
84 14 95 87 62 81 17 78 58
21 46 71 58 02 79 62 39 31 09
56 34 35 53 78 31 81 18 90 93 15
78 53 04 21 84 93 32 13 97 11 37 51
45 03 81 79 05 18 78 86 13 30 63 99 95
39 87 96 28 03 38 42 17 82 87 58 07 22 57
06 17 51 17 07 93 09 07 75 97 95 78 87 08 53
67 66 59 60 88 99 94 65 55 77 55 34 27 53 78 28
76 40 41 04 87 16 09 42 75 69 23 97 30 60 10 79 87
12 10 44 26 21 36 32 84 98 60 13 12 36 16 63 31 91 35
70 39 06 05 55 27 38 48 28 22 34 35 62 62 15 14 94 89 86
66 56 68 84 96 21 34 34 34 81 62 40 65 54 62 05 98 03 02 60
38 89 46 37 99 54 34 53 36 14 70 26 02 90 45 13 31 61 83 73 47
36 10 63 96 60 49 41 05 37 42 14 58 84 93 96 17 09 43 05 43 06 59
66 57 87 57 61 28 37 51 84 73 79 15 39 95 88 87 43 39 11 86 77 74 18
54 42 05 79 30 49 99 73 46 37 50 02 45 09 54 52 27 95 27 65 19 45 26 45
71 39 17 78 76 29 52 90 18 99 78 19 35 62 71 19 23 65 93 85 49 33 75 09 02
33 24 47 61 60 55 32 88 57 55 91 54 46 57 07 77 98 52 80 99 24 25 46 78 79 05
92 09 13 55 10 67 26 78 76 82 63 49 51 31 24 68 05 57 07 54 69 21 67 43 17 63 12
24 59 06 08 98 74 66 26 61 60 13 03 09 09 24 30 71 08 88 70 72 70 29 90 11 82 41 34
66 82 67 04 36 60 92 77 91 85 62 49 59 61 30 90 29 94 26 41 89 04 53 22 83 41 09 74 90
48 28 26 37 28 52 77 26 51 32 18 98 79 36 62 13 17 08 19 54 89 29 73 68 42 14 08 16 70 37
37 60 69 70 72 71 09 59 13 60 38 13 57 36 09 30 43 89 30 39 15 02 44 73 05 73 26 63 56 86 12
55 55 85 50 62 99 84 77 28 85 03 21 27 22 19 26 82 69 54 04 13 07 85 14 01 15 70 59 89 95 10 19
04 09 31 92 91 38 92 86 98 75 21 05 64 42 62 84 36 20 73 42 21 23 22 51 51 79 25 45 85 53 03 43 22
75 63 02 49 14 12 89 14 60 78 92 16 44 82 38 30 72 11 46 52 90 27 08 65 78 03 85 41 57 79 39 52 33 48
78 27 56 56 39 13 19 43 86 72 58 95 39 07 04 34 21 98 39 15 39 84 89 69 84 46 37 57 59 35 59 50 26 15 93
42 89 36 27 78 91 24 11 17 41 05 94 07 69 51 96 03 96 47 90 90 45 91 20 50 56 10 32 36 49 04 53 85 92 25 65
52 09 61 30 61 97 66 21 96 92 98 90 06 34 96 60 32 69 68 33 75 84 18 31 71 50 84 63 03 03 19 11 28 42 75 45 45
61 31 61 68 96 34 49 39 05 71 76 59 62 67 06 47 96 99 34 21 32 47 52 07 71 60 42 72 94 56 82 83 84 40 94 87 82 46
01 20 60 14 17 38 26 78 66 81 45 95 18 51 98 81 48 16 53 88 37 52 69 95 72 93 22 34 98 20 54 27 73 61 56 63 60 34 63
93 42 94 83 47 61 27 51 79 79 45 01 44 73 31 70 83 42 88 25 53 51 30 15 65 94 80 44 61 84 12 77 02 62 02 65 94 42 14 94
32 73 09 67 68 29 74 98 10 19 85 48 38 31 85 67 53 93 93 77 47 67 39 72 94 53 18 43 77 40 78 32 29 59 24 06 02 83 50 60 66
32 01 44 30 16 51 15 81 98 15 10 62 86 79 50 62 45 60 70 38 31 85 65 61 64 06 69 84 14 22 56 43 09 48 66 69 83 91 60 40 36 61
92 48 22 99 15 95 64 43 01 16 94 02 99 19 17 69 11 58 97 56 89 31 77 45 67 96 12 73 08 20 36 47 81 44 50 64 68 85 40 81 85 52 09
91 35 92 45 32 84 62 15 19 64 21 66 06 01 52 80 62 59 12 25 88 28 91 50 40 16 22 99 92 79 87 51 21 77 74 77 07 42 38 42 74 83 02 05
46 19 77 66 24 18 05 32 02 84 31 99 92 58 96 72 91 36 62 99 55 29 53 42 12 37 26 58 89 50 66 19 82 75 12 48 24 87 91 85 02 07 03 76 86
99 98 84 93 07 17 33 61 92 20 66 60 24 66 40 30 67 05 37 29 24 96 03 27 70 62 13 04 45 47 59 88 43 20 66 15 46 92 30 04 71 66 78 70 53 99
67 60 38 06 88 04 17 72 10 99 71 07 42 25 54 05 26 64 91 50 45 71 06 30 67 48 69 82 08 56 80 67 18 46 66 63 01 20 08 80 47 07 91 16 03 79 87
18 54 78 49 80 48 77 40 68 23 60 88 58 80 33 57 11 69 55 53 64 02 94 49 60 92 16 35 81 21 82 96 25 24 96 18 02 05 49 03 50 77 06 32 84 27 18 38
68 01 50 04 03 21 42 94 53 24 89 05 92 26 52 36 68 11 85 01 04 42 02 45 15 06 50 04 53 73 25 74 81 88 98 21 67 84 79 97 99 20 95 04 40 46 02 58 87
94 10 02 78 88 52 21 03 88 60 06 53 49 71 20 91 12 65 07 49 21 22 11 41 58 99 36 16 09 48 17 24 52 36 23 15 72 16 84 56 02 99 43 76 81 71 29 39 49 17
64 39 59 84 86 16 17 66 03 09 43 06 64 18 63 29 68 06 23 07 87 14 26 35 17 12 98 41 53 64 78 18 98 27 28 84 80 67 75 62 10 11 76 90 54 10 05 54 41 39 66
43 83 18 37 32 31 52 29 95 47 08 76 35 11 04 53 35 43 34 10 52 57 12 36 20 39 40 55 78 44 07 31 38 26 08 15 56 88 86 01 52 62 10 24 32 05 60 65 53 28 57 99
03 50 03 52 07 73 49 92 66 80 01 46 08 67 25 36 73 93 07 42 25 53 13 96 76 83 87 90 54 89 78 22 78 91 73 51 69 09 79 94 83 53 09 40 69 62 10 79 49 47 03 81 30
71 54 73 33 51 76 59 54 79 37 56 45 84 17 62 21 98 69 41 95 65 24 39 37 62 03 24 48 54 64 46 82 71 78 33 67 09 16 96 68 52 74 79 68 32 21 13 78 96 60 09 69 20 36
73 26 21 44 46 38 17 83 65 98 07 23 52 46 61 97 33 13 60 31 70 15 36 77 31 58 56 93 75 68 21 36 69 53 90 75 25 82 39 50 65 94 29 30 11 33 11 13 96 02 56 47 07 49 02
76 46 73 30 10 20 60 70 14 56 34 26 37 39 48 24 55 76 84 91 39 86 95 61 50 14 53 93 64 67 37 31 10 84 42 70 48 20 10 72 60 61 84 79 69 65 99 73 89 25 85 48 92 56 97 16
03 14 80 27 22 30 44 27 67 75 79 32 51 54 81 29 65 14 19 04 13 82 04 91 43 40 12 52 29 99 07 76 60 25 01 07 61 71 37 92 40 47 99 66 57 01 43 44 22 40 53 53 09 69 26 81 07
49 80 56 90 93 87 47 13 75 28 87 23 72 79 32 18 27 20 28 10 37 59 21 18 70 04 79 96 03 31 45 71 81 06 14 18 17 05 31 50 92 79 23 47 09 39 47 91 43 54 69 47 42 95 62 46 32 85
37 18 62 85 87 28 64 05 77 51 47 26 30 65 05 70 65 75 59 80 42 52 25 20 44 10 92 17 71 95 52 14 77 13 24 55 11 65 26 91 01 30 63 15 49 48 41 17 67 47 03 68 20 90 98 32 04 40 68
90 51 58 60 06 55 23 68 05 19 76 94 82 36 96 43 38 90 87 28 33 83 05 17 70 83 96 93 06 04 78 47 80 06 23 84 75 23 87 72 99 14 50 98 92 38 90 64 61 58 76 94 36 66 87 80 51 35 61 38
57 95 64 06 53 36 82 51 40 33 47 14 07 98 78 65 39 58 53 06 50 53 04 69 40 68 36 69 75 78 75 60 03 32 39 24 74 47 26 90 13 40 44 71 90 76 51 24 36 50 25 45 70 80 61 80 61 43 90 64 11
18 29 86 56 68 42 79 10 42 44 30 12 96 18 23 18 52 59 02 99 67 46 60 86 43 38 55 17 44 93 42 21 55 14 47 34 55 16 49 24 23 29 96 51 55 10 46 53 27 92 27 46 63 57 30 65 43 27 21 20 24 83
81 72 93 19 69 52 48 01 13 83 92 69 20 48 69 59 20 62 05 42 28 89 90 99 32 72 84 17 08 87 36 03 60 31 36 36 81 26 97 36 48 54 56 56 27 16 91 08 23 11 87 99 33 47 02 14 44 73 70 99 43 35 33
90 56 61 86 56 12 70 59 63 32 01 15 81 47 71 76 95 32 65 80 54 70 34 51 40 45 33 04 64 55 78 68 88 47 31 47 68 87 03 84 23 44 89 72 35 08 31 76 63 26 90 85 96 67 65 91 19 14 17 86 04 71 32 95
37 13 04 22 64 37 37 28 56 62 86 33 07 37 10 44 52 82 52 06 19 52 57 75 90 26 91 24 06 21 14 67 76 30 46 14 35 89 89 41 03 64 56 97 87 63 22 34 03 79 17 45 11 53 25 56 96 61 23 18 63 31 37 37 47
77 23 26 70 72 76 77 04 28 64 71 69 14 85 96 54 95 48 06 62 99 83 86 77 97 75 71 66 30 19 57 90 33 01 60 61 14 12 90 99 32 77 56 41 18 14 87 49 10 14 90 64 18 50 21 74 14 16 88 05 45 73 82 47 74 44
22 97 41 13 34 31 54 61 56 94 03 24 59 27 98 77 04 09 37 40 12 26 87 09 71 70 07 18 64 57 80 21 12 71 83 94 60 39 73 79 73 19 97 32 64 29 41 07 48 84 85 67 12 74 95 20 24 52 41 67 56 61 29 93 35 72 69
72 23 63 66 01 11 07 30 52 56 95 16 65 26 83 90 50 74 60 18 16 48 43 77 37 11 99 98 30 94 91 26 62 73 45 12 87 73 47 27 01 88 66 99 21 41 95 80 02 53 23 32 61 48 32 43 43 83 14 66 95 91 19 81 80 67 25 88
08 62 32 18 92 14 83 71 37 96 11 83 39 99 05 16 23 27 10 67 02 25 44 11 55 31 46 64 41 56 44 74 26 81 51 31 45 85 87 09 81 95 22 28 76 69 46 48 64 87 67 76 27 89 31 11 74 16 62 03 60 94 42 47 09 34 94 93 72
56 18 90 18 42 17 42 32 14 86 06 53 33 95 99 35 29 15 44 20 49 59 25 54 34 59 84 21 23 54 35 90 78 16 93 13 37 88 54 19 86 67 68 55 66 84 65 42 98 37 87 56 33 28 58 38 28 38 66 27 52 21 81 15 08 22 97 32 85 27
91 53 40 28 13 34 91 25 01 63 50 37 22 49 71 58 32 28 30 18 68 94 23 83 63 62 94 76 80 41 90 22 82 52 29 12 18 56 10 08 35 14 37 57 23 65 67 40 72 39 93 39 70 89 40 34 07 46 94 22 20 05 53 64 56 30 05 56 61 88 27
23 95 11 12 37 69 68 24 66 10 87 70 43 50 75 07 62 41 83 58 95 93 89 79 45 39 02 22 05 22 95 43 62 11 68 29 17 40 26 44 25 71 87 16 70 85 19 25 59 94 90 41 41 80 61 70 55 60 84 33 95 76 42 63 15 09 03 40 38 12 03 32
09 84 56 80 61 55 85 97 16 94 82 94 98 57 84 30 84 48 93 90 71 05 95 90 73 17 30 98 40 64 65 89 07 79 09 19 56 36 42 30 23 69 73 72 07 05 27 61 24 31 43 48 71 84 21 28 26 65 65 59 65 74 77 20 10 81 61 84 95 08 52 23 70
47 81 28 09 98 51 67 64 35 51 59 36 92 82 77 65 80 24 72 53 22 07 27 10 21 28 30 22 48 82 80 48 56 20 14 43 18 25 50 95 90 31 77 08 09 48 44 80 90 22 93 45 82 17 13 96 25 26 08 73 34 99 06 49 24 06 83 51 40 14 15 10 25 01
54 25 10 81 30 64 24 74 75 80 36 75 82 60 22 69 72 91 45 67 03 62 79 54 89 74 44 83 64 96 66 73 44 30 74 50 37 05 09 97 70 01 60 46 37 91 39 75 75 18 58 52 72 78 51 81 86 52 08 97 01 46 43 66 98 62 81 18 70 93 73 08 32 46 34
96 80 82 07 59 71 92 53 19 20 88 66 03 26 26 10 24 27 50 82 94 73 63 08 51 33 22 45 19 13 58 33 90 15 22 50 36 13 55 06 35 47 82 52 33 61 36 27 28 46 98 14 73 20 73 32 16 26 80 53 47 66 76 38 94 45 02 01 22 52 47 96 64 58 52 39
88 46 23 39 74 63 81 64 20 90 33 33 76 55 58 26 10 46 42 26 74 74 12 83 32 43 09 02 73 55 86 54 85 34 28 23 29 79 91 62 47 41 82 87 99 22 48 90 20 05 96 75 95 04 43 28 81 39 81 01 28 42 78 25 39 77 90 57 58 98 17 36 73 22 63 74 51
29 39 74 94 95 78 64 24 38 86 63 87 93 06 70 92 22 16 80 64 29 52 20 27 23 50 14 13 87 15 72 96 81 22 08 49 72 30 70 24 79 31 16 64 59 21 89 34 96 91 48 76 43 53 88 01 57 80 23 81 90 79 58 01 80 87 17 99 86 90 72 63 32 69 14 28 88 69
37 17 71 95 56 93 71 35 43 45 04 98 92 94 84 96 11 30 31 27 31 60 92 03 48 05 98 91 86 94 35 90 90 08 48 19 33 28 68 37 59 26 65 96 50 68 22 07 09 49 34 31 77 49 43 06 75 17 81 87 61 79 52 26 27 72 29 50 07 98 86 01 17 10 46 64 24 18 56
51 30 25 94 88 85 79 91 40 33 63 84 49 67 98 92 15 26 75 19 82 05 18 78 65 93 61 48 91 43 59 41 70 51 22 15 92 81 67 91 46 98 11 11 65 31 66 10 98 65 83 21 05 56 05 98 73 67 46 74 69 34 08 30 05 52 07 98 32 95 30 94 65 50 24 63 28 81 99 57
19 23 61 36 09 89 71 98 65 17 30 29 89 26 79 74 94 11 44 48 97 54 81 55 39 66 69 45 28 47 13 86 15 76 74 70 84 32 36 33 79 20 78 14 41 47 89 28 81 05 99 66 81 86 38 26 06 25 13 60 54 55 23 53 27 05 89 25 23 11 13 54 59 54 56 34 16 24 53 44 06
13 40 57 72 21 15 60 08 04 19 11 98 34 45 09 97 86 71 03 15 56 19 15 44 97 31 90 04 87 87 76 08 12 30 24 62 84 28 12 85 82 53 99 52 13 94 06 65 97 86 09 50 94 68 69 74 30 67 87 94 63 07 78 27 80 36 69 41 06 92 32 78 37 82 30 05 18 87 99 72 19 99
44 20 55 77 69 91 27 31 28 81 80 27 02 07 97 23 95 98 12 25 75 29 47 71 07 47 78 39 41 59 27 76 13 15 66 61 68 35 69 86 16 53 67 63 99 85 41 56 08 28 33 40 94 76 90 85 31 70 24 65 84 65 99 82 19 25 54 37 21 46 33 02 52 99 51 33 26 04 87 02 08 18 96
54 42 61 45 91 06 64 79 80 82 32 16 83 63 42 49 19 78 65 97 40 42 14 61 49 34 04 18 25 98 59 30 82 72 26 88 54 36 21 75 03 88 99 53 46 51 55 78 22 94 34 40 68 87 84 25 30 76 25 08 92 84 42 61 40 38 09 99 40 23 29 39 46 55 10 90 35 84 56 70 63 23 91 39
52 92 03 71 89 07 09 37 68 66 58 20 44 92 51 56 13 71 79 99 26 37 02 06 16 67 36 52 58 16 79 73 56 60 59 27 44 77 94 82 20 50 98 33 09 87 94 37 40 83 64 83 58 85 17 76 53 02 83 52 22 27 39 20 48 92 45 21 09 42 24 23 12 37 52 28 50 78 79 20 86 62 73 20 59
54 96 80 15 91 90 99 70 10 09 58 90 93 50 81 99 54 38 36 10 30 11 35 84 16 45 82 18 11 97 36 43 96 79 97 65 40 48 23 19 17 31 64 52 65 65 37 32 65 76 99 79 34 65 79 27 55 33 03 01 33 27 61 28 66 08 04 70 49 46 48 83 01 45 19 96 13 81 14 21 31 79 93 85 50 05
92 92 48 84 59 98 31 53 23 27 15 22 79 95 24 76 05 79 16 93 97 89 38 89 42 83 02 88 94 95 82 21 01 97 48 39 31 78 09 65 50 56 97 61 01 07 65 27 21 23 14 15 80 97 44 78 49 35 33 45 81 74 34 05 31 57 09 38 94 07 69 54 69 32 65 68 46 68 78 90 24 28 49 51 45 86 35
41 63 89 76 87 31 86 09 46 14 87 82 22 29 47 16 13 10 70 72 82 95 48 64 58 43 13 75 42 69 21 12 67 13 64 85 58 23 98 09 37 76 05 22 31 12 66 50 29 99 86 72 45 25 10 28 19 06 90 43 29 31 67 79 46 25 74 14 97 35 76 37 65 46 23 82 06 22 30 76 93 66 94 17 96 13 20 72
63 40 78 08 52 09 90 41 70 28 36 14 46 44 85 96 24 52 58 15 87 37 05 98 99 39 13 61 76 38 44 99 83 74 90 22 53 80 56 98 30 51 63 39 44 30 91 91 04 22 27 73 17 35 53 18 35 45 54 56 27 78 48 13 69 36 44 38 71 25 30 56 15 22 73 43 32 69 59 25 93 83 45 11 34 94 44 39 92
12 36 56 88 13 96 16 12 55 54 11 47 19 78 17 17 68 81 77 51 42 55 99 85 66 27 81 79 93 42 65 61 69 74 14 01 18 56 12 01 58 37 91 22 42 66 83 25 19 04 96 41 25 45 18 69 96 88 36 93 10 12 98 32 44 83 83 04 72 91 04 27 73 07 34 37 71 60 59 31 01 54 54 44 96 93 83 36 04 45
30 18 22 20 42 96 65 79 17 41 55 69 94 81 29 80 91 31 85 25 47 26 43 49 02 99 34 67 99 76 16 14 15 93 08 32 99 44 61 77 67 50 43 55 87 55 53 72 17 46 62 25 50 99 73 05 93 48 17 31 70 80 59 09 44 59 45 13 74 66 58 94 87 73 16 14 85 38 74 99 64 23 79 28 71 42 20 37 82 31 23
51 96 39 65 46 71 56 13 29 68 53 86 45 33 51 49 12 91 21 21 76 85 02 17 98 15 46 12 60 21 88 30 92 83 44 59 42 50 27 88 46 86 94 73 45 54 23 24 14 10 94 21 20 34 23 51 04 83 99 75 90 63 60 16 22 33 83 70 11 32 10 50 29 30 83 46 11 05 31 17 86 42 49 01 44 63 28 60 07 78 95 40
44 61 89 59 04 49 51 27 69 71 46 76 44 04 09 34 56 39 15 06 94 91 75 90 65 27 56 23 74 06 23 33 36 69 14 39 05 34 35 57 33 22 76 46 56 10 61 65 98 09 16 69 04 62 65 18 99 76 49 18 72 66 73 83 82 40 76 31 89 91 27 88 17 35 41 35 32 51 32 67 52 68 74 85 80 57 07 11 62 66 47 22 67
65 37 19 97 26 17 16 24 24 17 50 37 64 82 24 36 32 11 68 34 69 31 32 89 79 93 96 68 49 90 14 23 04 04 67 99 81 74 70 74 36 96 68 09 64 39 88 35 54 89 96 58 66 27 88 97 32 14 06 35 78 20 71 06 85 66 57 02 58 91 72 05 29 56 73 48 86 52 09 93 22 57 79 42 12 01 31 68 17 59 63 76 07 77
73 81 14 13 17 20 11 09 01 83 08 85 91 70 84 63 62 77 37 07 47 01 59 95 39 69 39 21 99 09 87 02 97 16 92 36 74 71 90 66 33 73 73 75 52 91 11 12 26 53 05 26 26 48 61 50 90 65 01 87 42 47 74 35 22 73 24 26 56 70 52 05 48 41 31 18 83 27 21 39 80 85 26 08 44 02 71 07 63 22 05 52 19 08 20
17 25 21 11 72 93 33 49 64 23 53 82 03 13 91 65 85 02 40 05 42 31 77 42 05 36 06 54 04 58 07 76 87 83 25 57 66 12 74 33 85 37 74 32 20 69 03 97 91 68 82 44 19 14 89 28 85 85 80 53 34 87 58 98 88 78 48 65 98 40 11 57 10 67 70 81 60 79 74 72 97 59 79 47 30 20 54 80 89 91 14 05 33 36 79 39
60 85 59 39 60 07 57 76 77 92 06 35 15 72 23 41 45 52 95 18 64 79 86 53 56 31 69 11 91 31 84 50 44 82 22 81 41 40 30 42 30 91 48 94 74 76 64 58 74 25 96 57 14 19 03 99 28 83 15 75 99 01 89 85 79 50 03 95 32 67 44 08 07 41 62 64 29 20 14 76 26 55 48 71 69 66 19 72 44 25 14 01 48 74 12 98 07
64 66 84 24 18 16 27 48 20 14 47 69 30 86 48 40 23 16 61 21 51 50 26 47 35 33 91 28 78 64 43 68 04 79 51 08 19 60 52 95 06 68 46 86 35 97 27 58 04 65 30 58 99 12 12 75 91 39 50 31 42 64 70 04 46 07 98 73 98 93 37 89 77 91 64 71 64 65 66 21 78 62 81 74 42 20 83 70 73 95 78 45 92 27 34 53 71 15
30 11 85 31 34 71 13 48 05 14 44 03 19 67 23 73 19 57 06 90 94 72 57 69 81 62 59 68 88 57 55 69 49 13 07 87 97 80 89 05 71 05 05 26 38 40 16 62 45 99 18 38 98 24 21 26 62 74 69 04 85 57 77 35 58 67 91 79 79 57 86 28 66 34 72 51 76 78 36 95 63 90 08 78 47 63 45 31 22 70 52 48 79 94 15 77 61 67 68
23 33 44 81 80 92 93 75 94 88 23 61 39 76 22 03 28 94 32 06 49 65 41 34 18 23 08 47 62 60 03 63 33 13 80 52 31 54 73 43 70 26 16 69 57 87 83 31 03 93 70 81 47 95 77 44 29 68 39 51 56 59 63 07 25 70 07 77 43 53 64 03 94 42 95 39 18 01 66 21 16 97 20 50 90 16 70 10 95 69 29 06 25 61 41 26 15 59 63 35
DATABLOCK_END
triangleArray		DB 5000H Dup 0 ; Sum of the First n Natural Numbers = n(n+1)/2
rowIndexArray		DD 101H Dup 0 ; used to index into rows

; EULER problem 19
;jAaa		DD 0
;jdn			DD 0
jYear		DD 1962
jMonth		DD 6
jDay		DD 22
loopYear		DD 1901
loopMonth		DD 1
sundaySum		DD 0

; EULER problem 20
bigNum1			DD 400H Dup 0
carryPart		DD 0
digitCounter	DD 0
numDoubleWords	DD 0

; EULER problem 21
spdArray		DD 10000 Dup 0

; EULER problem 22
fileBuffer22		DB 0B600H Dup 0
hMemory 			DD 0
pMemory				DD 0
hHeap				DD 0
hFileMap			DD 0
ofn					OPENFILENAME
spareString			DB 100H Dup 0

; EULER problem 23
abundantNumArray	DD 6965 Dup 0
spareString_1			DB 100H Dup 0	; this needs to remain right after abundantNumArray since it's used as end of array marker
spareString_2			DB 9000H Dup 0

; EULER problem 25
decimalString		DB 400H Dup 0
numDigits			DD 0
n1					DD 0
n2					DD 0
bigNum2				DD 400H Dup 0
bigNum3				DD 400H Dup 0

; test area
filterString 		DB "All Files", 0, "*.*", 0
             		DB "Text Files", 0, "*.txt", 0, 0
buffer 				DB MAXSIZE Dup 0
pArray				DD ?
string1		 		DB "test string 1", 0
string2		 		DB "test string 2", 0
userAgent			DB "garbo superduper browser v1.00", 0
;url_1				DB "www.microsoft.com", 0
;url_1				DB "http://192.168.1.254/", 0
;url_1				DB "http://www.translationscience.com/", 0
url_1				DB "http://www.yahoo.com/", 0
url_2				DB "http://translationscience.com/test_186_file_upload.php", 0
url_3				DB "http://translationscience.com/test_188_form_test.php", 0
url_4				DB "http://translationscience.com", 0
url_5				DB "translationscience.com", 0
Align 4
objectName			DB "test_188_form_test.php", 0
Align 4
objectName_2		DB "test_187_file_upload.php", 0
Align 4
acceptTypes			DB "*/*", 0	; used by HttpOpenRequest

hdrs				DB "Content-Type: application/x-www-form-urlencoded", 0
frmdata				DB "fname=garbo&age=50&submit=submit", 0

hdrs_2				DB 'Content-Type: multipart/form-data; boundary=AaB03x', 0
frmdata_2			DB '', 0DH, 0AH
					DB '--AaB03x', 0DH, 0AH
					DB 'Content-Disposition: form-data; name="submit"', 0DH, 0AH
					DB '', 0DH, 0AH
					DB 'Upload file', 0DH, 0AH
					DB '--AaB03x', 0DH, 0AH
					DB 'Content-Disposition: form-data; name="file"; filename="file5.txt"', 0DH, 0AH
					DB 'Content-Type: text/plain', 0DH, 0AH
					DB '', 0DH, 0AH
					DB '... contents of file1.txt ...', 0DH, 0AH, 'sdfssfs', 0DH, 0AH
					DB '--AaB03x--', 0DH, 0AH

frmdata_2_A			DB '', 0DH, 0AH
					DB '--AaB03x', 0DH, 0AH
					DB 'Content-Disposition: form-data; name="submit"', 0DH, 0AH
					DB '', 0DH, 0AH
					DB 'Upload file', 0DH, 0AH
					DB '--AaB03x', 0DH, 0AH
					DB 'Content-Disposition: form-data; name="file"; filename="file5.txt"', 0DH, 0AH
					DB 'Content-Type: text/plain', 0DH, 0AH
					DB '', 0DH, 0AH
frmdata_2_B			DB 0DH, 0AH
					DB '--AaB03x--', 0DH, 0AH

totalCharCount		DD 0
ptrFrmData_2		DD 0

; need to correct some of the autoformatting that Easy Code did here
;frmdata_3 DATABLOCK_BEGIN
;
;--AaB03x
;Content-Disposition: form-data; name="submit"
;
;Upload file
;--AaB03x
;Content-Disposition: form-data; name="file"; filename="file4.txt"
;Content-Type: text/plain
;
;... contents of file1.txt ...
;--AaB03x--
;DATABLOCK_END

hInternet 			DD 0 ; used with 1st connection method = WinHTTP
hInternet_1 		DD 0 ; used with 2nd (preferred) connection method = WinINet
hInternet_2 		DD 0
hInternet_3 		DD 0
; sizeInternetBuffer_1	DD 1000H ; not needed, use "SizeOf internetBuffer_1 - 1"
Align 4	; Win32 calls seems to require such alignment
internetBuffer_1	DB 41H Dup 0DDH
Align 4
internetBuffer_2	DB 80000H Dup 0 ; seems necessary to initialize to ZERO, or just first byte?
Align 4
internetBuffer		DB 100H Dup 0
numberOfBytesRead	DD 0
hConnected			DD 0
hOut				DD 0 ; for temp file
fileSize			DQ 0

pathName			DB "c:\test1.txt", 0
findData			WIN32_FIND_DATA

.Code

winMainProcedure Frame hWnd, uMsg, wParam, lParam
	Mov Eax, [uMsg]
	Mov Ecx, SizeOf WINMAIN_MESSAGES / 8
	Mov Edx, Addr WINMAIN_MESSAGES
:	Dec Ecx
	Js > L2
	Cmp [Edx + Ecx * 8], Eax
	Jne <
	Call [Edx + Ecx * 8 + 4]
	Ret
L2:	Xor Eax, Eax	;Return (FALSE)
	Ret
EndF

OnwinMainCreate: UseData winMainProcedure
	;==================================
	;Write the initialization code here
	;==================================
	Xor Eax, Eax	;Return (FALSE)
	Ret
EndU

OnwinMainClose: UseData winMainProcedure
	;=========================
	;Write the final code here
	;=========================
	Invoke IsModal, [hWnd]
	Or Eax, Eax		;Cmp Eax, FALSE
	Jz >
	Invoke EndModal, [hWnd], IDCANCEL
	Mov Eax, TRUE	;Return (TRUE)
:	Ret
EndU
OnwinMainClickBtn: UseData winMainProcedure

; I used to put a label here, but Easy Code seems to want to modify it

	Mov Eax, [wParam]
	Cmp Ax, IDC_WINMAIN_BTN1		; Is this button 1?
		Jnz >>.chkbtn2

	; This IS button 1 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure		; Button 1 but not left click

	; Button 1 AND left click so process
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem 1...', 'Project Euler', MB_OK

	; EULER problem 1
	; Initialize variables
	Mov Eax, 0				; Eax = Sum
	Mov Ecx, 999			; Ecx = Loop counter (candidate)

	; Processing loop
.loop_start:

.chkMod3:						; Check whether multiple of 3

	; Save variables before division
	Push Eax
	Push Ecx

	Mov Edx, 0					; Clear dividend, high
	Mov Eax, Ecx				; Dividend, low
	Mov Ecx, 3					; Divisor
	Div Ecx						; Eax = quotient, Edx = remainder

	; Restore variables after division
	Pop Ecx
	Pop Eax

	Cmp Edx, 0					; Edx holds remainder from division
		Jnz >>.chkMod5

	Add Eax, Ecx				; Multiple of 3 so add to sum
	Jmp >>.loopEndProcedure

.chkMod5:

	; Save variables before division
	Push Eax
	Push Ecx

	; Check whether multiple of 5
	Mov Edx, 0					; Clear dividend, high
	Mov Eax, Ecx				; Dividend, low
	Mov Ecx, 5					; Divisor
	Div Ecx						; Eax = quotient, Edx = remainder

	; Restore variables after division
	Pop Ecx
	Pop Eax

	Cmp Edx, 0					; Edx holds remainder from division
		Jnz >>.loopEndProcedure

	Add Eax, Ecx				; Multiple of 5 so add to sum

.loopEndProcedure:

	Loop .loop_start

	; Loop processing done, display result
	Invoke String, Eax, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Project Euler (Problem 1 answer = 233168)', MB_ICONINFORMATION

	Return (TRUE)

; ************************************************************************************
.chkbtn2:						; Previous button not clicked, check button 2

	Cmp Ax, IDC_WINMAIN_BTN2		; Is this button 2?
		Jnz >>.chkbtn14

	; This IS button 2 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Button 2 AND left click so process
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem 2...', 'Project Euler', MB_OK

	; EULER problem 2
	; Initialize variables
	Mov Ecx, 2						; Ecx = sum already includes 2
	;Mov Edx, 89					; max value
	Mov Edx, 4000000				; Edx = max value
	Mov Ebx, 2
	Mov [fib1], Ebx
	Mov Ebx, 3
	Mov [fib2], Ebx

	; WHILE loop test
.whileLoop:

	Mov Eax, 0
	Add Eax, [fib1]
	Add Eax, [fib2]

	Cmp Eax, Edx
		Ja >.whileLoopDone

	; Check whether current value is even and if so, add to total
	Test Eax, 1
		Jnz >.notEven
	Add Ecx, Eax

.notEven:

	Push Eax
	Push Ebx
	Push Ecx
	Push Edx

	; Display current loop value
	;Invoke String, Eax, Addr myStringVar, ecDecimal
	;Invoke MessageBoxA, [hWnd], Addr myStringVar, 'WHILE loop test', MB_ICONINFORMATION

	Pop Edx
	Pop Ecx
	Pop Ebx
	Pop Eax

	Mov Ebx, [fib2]
	Mov [fib1], Ebx
	Mov [fib2], Eax

	Jmp .whileLoop

.whileLoopDone:

	; Display answer
	Invoke String, Ecx, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Problem 2 answer = 4613732', MB_ICONINFORMATION

	Return (TRUE)

; ************************************************************************************
.chkbtn14:						; Previous button not clicked, check button 3

	Cmp Ax, IDC_WINMAIN_BTN3		; Is this button 3?
		Jnz >>.chkbtn19

	; This IS button 3 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Button 3 AND left click so process
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem 7...', 'Project Euler', MB_OK

	; save time1
	Invoke GetSystemTime, Addr time1

	; EULER problem 7
	; Initialize variables
	; Store 2 and 3 in knownPrimes array
	Mov Eax, 2						; first prime = 2
	Mov Ebx, Addr knownPrimes		; Ebx = ptr to knownPrimes[0]
	Mov [Ebx], Eax					; knownPrimes[0] = 2
	Add Ebx, 4						; increment Ebx = ptr to knownPrimes[1]
	Mov Eax, 3						; second prime = 3
	Mov [Ebx], Eax					; knownPrimes[0] = 3

	; Initialise other variables here (in case routine is re-executed)
	; First candidate to check = 5
	Mov Eax, 5
	Mov [candidate], Eax

	; Two primes already known (= 2, 3)
	Mov Eax, 2
	Mov [primeCount], Eax

	; Number of primes to calculate
	; Why not just use primeLimit? Is it modified somewhere? Eliminated in version 3.
	;Mov Eax, [primeLimitConstant]		; normally 10001
	;Mov [primeLimit1], Eax

	; For analysis purposes, count number of iterations in secondary loop
	Mov Eax, 0
	Mov [iterCounter2], Eax

.mainLoopStart:

	; Divide candidate by 2 since we only need to test primes up to candidate / 2
	Mov Edx, 0					; clear dividend, high
	Mov Eax, [candidate]		; dividend, low
	Mov Ecx, 2					; divisor
	Div Ecx						; Eax = quotient, Edx = remainder

	; candidateDividedByTwo = candidate / 2 (divide candidate by 2 and save for comparison)
	Mov [candidateDividedByTwo], Eax

	; primeFlag = TRUE
	Mov Eax, TRUE
	Mov [primeFlag], Eax

	; Ecx = loop counter
	Mov Ecx, 1

	; For analysis purposes, count number of iterations in secondary loop
	Mov Eax, 0
	Mov [iterCounter1], Eax

.secondaryLoop:

		; analysis
		Mov Eax, [iterCounter1]
		Inc Eax
		Mov [iterCounter1], Eax

		; load current prime to test
		Mov Ebx, Addr knownPrimes
		Mov Eax, [Ebx + 4 * Ecx]					; Ebx = 1, Eax = 3

		; if current prime > candidateDividedByTwo, we're done (candidate is prime)
		Cmp Eax, [candidateDividedByTwo]
		Ja >.testDone

		Push Ecx					; Ecx holds loop counter but needed here for division

		; Limit not yet reached so test this prime
		; Divide candidate by current prime of interest
		Mov Edx, 0					; clear dividend, high
		Mov Ecx, Eax				; divisor = current prime we are checking
		Mov Eax, [candidate]		; dividend, low
		Div Ecx						; Eax = quotient, Edx = remainder

		Pop Ecx						; Reload loop counter

		; see if candidate/current prime = modulo 0 (--> not prime)
		Cmp Edx, 0
		Jnz >.secondaryLoopEnd
			; primeFlag = FALSE
			Mov Eax, FALSE
			Mov [primeFlag], Eax
			Jmp >.testDone

.secondaryLoopEnd:

	; Increment counter to check next prime if counter <> primeCount (number of currently known primes)
	Inc Ecx
	Cmp Ecx, [primeCount]
	Jnz .secondaryLoop

.testDone:

	; analysis (add secondary loop counter to main loop counter)
	Mov Eax, [iterCounter1]
	Add Eax, [iterCounter2]
	Mov [iterCounter2], Eax

	; Get primeCount in Ecx
	Mov Ecx, [primeCount]

	; IF primeFlag = TRUE THEN add new prime to array
	Mov Eax, [primeFlag]
	Cmp Eax, TRUE
	Jnz >.mainLoopEnd
		Mov Eax, [candidate]
		Mov Ebx, Addr knownPrimes
		Mov [Ebx + 4 * Ecx], Eax			; save new prime at end of knownPrimes array
		Add Ecx, 1							; primeCount += 1
		Mov [primeCount], Ecx

.mainLoopEnd:

	; candidate += 2 (next odd number)
	Mov Eax, [candidate]
	Add Eax, 2
	Mov [candidate], Eax

	; Compare primeCount and primeLimit1, loop back if primeCount < primeLimit1
	Mov Eax, [primeLimit1]
	Cmp Ecx, Eax
	Jnz .mainLoopStart

.finalProcessing

	; save time2
	Push Ecx
	Invoke GetSystemTime, Addr time2
	Pop Ecx

	; Display final result (nth prime, n = primeCount)
	; Ecx = primeCount
	Mov Ebx, Addr knownPrimes
	Mov Eax, [Ebx + 4 * Ecx - 4]

	Invoke String, Eax, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'nth prime (answer = 104743)', MB_ICONINFORMATION

	; process time difference
	Invoke SystemTimeToFileTime, Addr time1, Addr timeFT1
	Invoke SystemTimeToFileTime, Addr time2, Addr timeFT2

	Mov Eax, [timeFT1.dwLowDateTime]
	Mov Ebx, [timeFT2.dwLowDateTime]
	Sub Ebx, Eax		; time difference is x 100 ns (1E-7)

	; Divide result to get ms
	Mov Edx, 0					; clear dividend, high
	Mov Eax, Ebx				; dividend, low
	Mov Ecx, 10000					; divisor
	Div Ecx						; Eax = quotient, Edx = remainder

	Invoke String, Eax, Addr clientTime, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr clientTime, 'time diff in ms', MB_ICONINFORMATION

	; display analysis result
	Mov Eax, [iterCounter2]
	Invoke String, Eax, Addr clientTime, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr clientTime, 'iterations', MB_ICONINFORMATION

	Return (TRUE)

; ************************************************************************************
.chkbtn19:						; Previous button not clicked, check button 4

	Cmp Ax, IDC_WINMAIN_BTN4		; Is this button 4?
		Jnz >>.chkbtn24

	; This IS button 4 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Button 3 AND left click so process
	;Invoke SetText, [hWnd], "You clicked button 3!!!"
	Invoke MessageBoxA, [hWnd], 'Test area+Bunch of junk here', 'Message box test', MB_ICONINFORMATION

	Invoke FindFirstFile, Addr pathName, Addr findData

	Invoke FileTimeToSystemTime, Addr findData.ftCreationTime, Addr time1

.AAA_breakpoint_11

	Return (TRUE)



	; FOR TESTING ONLY!
	;Jmp >>.AAA_breakpoint_12

	; ************************************
	;
	; uploading a user-specified file to the TSLLC server
	;
	; ************************************

	; user specifies file
	Push SizeOf ofn
	Pop [ofn.lStructSize]
	Push [hWnd]
	Pop [ofn.hwndOwner]
	Push NULL
	Pop [ofn.hInstance]

	Mov [ofn.lpstrFilter], Addr filterString
	Mov [ofn.lpstrFile], Addr buffer
 	Mov D[ofn.nMaxFile], MAXSIZE

	Invoke GetOpenFileName, Addr ofn

	Invoke MessageBoxA, [hWnd], [ofn.lpstrFile], 'Project Euler', MB_ICONINFORMATION

	;
	; load file into memory map yyyy
	; open file for reading
	;

	Invoke CreateFile, [ofn.lpstrFile], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL

	Cmp Eax, INVALID_HANDLE_VALUE
	Jne >.OK_40
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'CreateFile (2) failed, error code from GetLastError', MB_ICONINFORMATION
		Return (TRUE)

.OK_40

	Mov [hFile], Eax

	; check file length (char count for file)
	Invoke GetFileSizeEx, [hFile], Addr fileSize

	; total char count = file char count + static string char count
	Mov Eax, [fileSize] ; ignoring high double word (assumed = 0)
	Mov [totalCharCount], Eax
	Add D[totalCharCount], SizeOf frmdata_2_A
	Add D[totalCharCount], SizeOf frmdata_2_B

	Invoke CreateFileMapping, [hFile], NULL, PAGE_READONLY, 0, 0, NULL

	Cmp Eax, NULL
	Jne >.OK_41
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'CreateFileMapping failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke CloseHandle, [hFile]
		Return (TRUE)

.OK_41

	Mov [hFileMap], Eax

	Invoke MapViewOfFile, [hFileMap], FILE_MAP_READ, 0, 0, 0

	Cmp Eax, NULL
	Jne >.OK_42
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'MapViewOfFile failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke CloseHandle, [hFileMap]
		Invoke CloseHandle, [hFile]
		Return (TRUE)

.OK_42

	Mov [pMemory], Eax

	; display
	Invoke SetDlgItemText, [hWnd], IDC_WINMAIN_EDIT1, [pMemory]

	; alloc memory for string
	Invoke GetProcessHeap
	Mov [hHeap], Eax
	Mov Ebx, [totalCharCount]
	Inc Ebx	; allows an extra 0 to mark end of string
	Invoke HeapAlloc, [hHeap], HEAP_ZERO_MEMORY, Ebx
	Mov [ptrFrmData_2], Eax
	
	;
	; !!!!!!!!!!!!!!!!!!!!!!!!!! BAD CODE HERE !!!!!!!!!!!!!!!!!!!!!!
	;

	; copy string A to allocated memory
	Mov Eax, [ptrFrmData_2]
	Invoke lszCopyn, Eax, Addr frmdata_2_A, SizeOf frmdata_2_A

.AAA_breakpoint_13

	; append file to allocated memory
	Mov Eax, [ptrFrmData_2]
	Add Eax, SizeOf frmdata_2_A
	Invoke lszCopyn, Eax, [pMemory], [fileSize]

	; need to insert correct FILE NAME!?

	; copy string B to allocated memory
	Mov Eax, [ptrFrmData_2]
	Add Eax, SizeOf frmdata_2_A
	Add Eax, [fileSize]
	Invoke lszCopyn, Eax, Addr frmdata_2_B, SizeOf frmdata_2_B

	; internet operations to upload file

	Invoke InternetOpen, Addr userAgent, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0

Cmp Eax, NULL
		Jne >.OK_43
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'InternetOpen failed, error code from GetLastError', MB_ICONINFORMATION
		Return (TRUE)

.OK_43

	Mov [hInternet_1], Eax

	; zzzzzz
	Invoke InternetConnect, [hInternet_1], Addr url_5, INTERNET_DEFAULT_HTTP_PORT, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 1
	; perhaps last value could be NULL instead of 1?

Cmp Eax, NULL
		Jne >.OK_44
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'InternetConnect failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Return (TRUE)

.OK_44

	Mov [hInternet_2], Eax

	; here is where problem is happening
	Invoke HttpOpenRequest, [hInternet_2], "POST", Addr objectName_2, NULL, NULL, Addr acceptTypes, 0, 1

	Cmp Eax, NULL
		Jne >.OK_45
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'HttpOpenRequest failed 2, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Invoke InternetCloseHandle, [hInternet_2]
		Return (TRUE)

.OK_45

;.AAA_breakpoint_11

	Mov [hInternet_3], Eax

	Invoke HttpSendRequest, [hInternet_3], Addr hdrs_2, SizeOf hdrs_2 - 1, [ptrFrmData_2], [totalCharCount]

	Cmp Eax, TRUE	; different return codes here!
		Je >.OK_46
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'HttpSendRequest failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Invoke InternetCloseHandle, [hInternet_2]
		Invoke InternetCloseHandle, [hInternet_3]
		Return (TRUE)

.OK_46

	; open a temporary file to save the data
	; could use FILE_FLAG_DELETE_ON_CLOSE so file is automatically deleted
	; but then need to have a way to also read the same temp file

	Invoke CreateFile, 'c:/test5.txt', GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL

	Cmp Eax, INVALID_HANDLE_VALUE
		Jne >.OK_47
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'CreateFile failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Invoke InternetCloseHandle, [hInternet_2]
		Invoke InternetCloseHandle, [hInternet_3]
		Return (TRUE)

.OK_47

	Mov [hOut], Eax

.loop_readfile_5

	Invoke InternetReadFile, [hInternet_3], Addr internetBuffer, SizeOf internetBuffer, Addr nIn

	Cmp Eax, NULL
		Jne >.OK_48
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'InternetReadFile failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Invoke InternetCloseHandle, [hInternet_2]
		Invoke InternetCloseHandle, [hInternet_3]
		Invoke CloseHandle, [hOut]
		Return (TRUE)

.OK_48

	; if no bytes were returned this time, jump to final processing
	Mov Eax, [nIn]
	Cmp Eax, 0
		Je >>.done_readfile_5

	; write the current bytes to the temp file
	Invoke WriteFile, [hOut], Addr internetBuffer, [nIn], Addr nOut, NULL

	Mov Ebx, [nIn]	; nIn, nOut are more traditional
	Cmp Ebx, [nOut]
		Je .loop_readfile_5 ; if write operation was OK, do it again
		; error processing
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'WriteFile failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Invoke InternetCloseHandle, [hInternet_2]
		Invoke InternetCloseHandle, [hInternet_3]
		Invoke CloseHandle, [hOut]
		Return (TRUE)

	; END OF LOOP

.done_readfile_5

	; file is on disk, internet operation complete
	Invoke InternetCloseHandle, [hInternet_1]
	Invoke InternetCloseHandle, [hInternet_2]
	Invoke InternetCloseHandle, [hInternet_3]
	Invoke CloseHandle, [hOut]





	; close handles
	Invoke HeapFree, [hHeap], NULL, [ptrFrmData_2] ; unTESTED!!!

	Invoke UnmapViewOfFile, [pMemory]
	Invoke CloseHandle, [hFileMap]
	Invoke CloseHandle, [hFile]

	Return (TRUE)

	; ************************************
	;
	; testing internet access, 5th attempt
	;
	; FILE UPLOAD !!!
	; writing returned data directly to (temp) file
	; ************************************

.AAA_breakpoint_12

	Invoke InternetOpen, Addr userAgent, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0

Cmp Eax, NULL
		Jne >.OK_31
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'InternetOpen failed, error code from GetLastError', MB_ICONINFORMATION
		Return (TRUE)

.OK_31

	Mov [hInternet_1], Eax

	Invoke InternetConnect, [hInternet_1], Addr url_5, INTERNET_DEFAULT_HTTP_PORT, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 1
	; perhaps last value could be NULL instead of 1?

Cmp Eax, NULL
		Jne >.OK_32
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'InternetConnect failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Return (TRUE)

.OK_32

	Mov [hInternet_2], Eax

	Invoke HttpOpenRequest, [hInternet_2], "POST", Addr objectName_2, NULL, NULL, Addr acceptTypes, 0, 1

	Cmp Eax, NULL
		Jne >.OK_33
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'HttpOpenRequest failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Invoke InternetCloseHandle, [hInternet_2]
		Return (TRUE)

.OK_33

	Mov [hInternet_3], Eax

	Invoke HttpSendRequest, [hInternet_3], Addr hdrs_2, SizeOf hdrs_2 - 1, Addr frmdata_2, SizeOf frmdata_2 - 1

	Cmp Eax, TRUE	; different return codes here!
		Je >.OK_34
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'HttpSendRequest failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Invoke InternetCloseHandle, [hInternet_2]
		Invoke InternetCloseHandle, [hInternet_3]
		Return (TRUE)

.OK_34

	; open a temporary file to save the data
	; could use FILE_FLAG_DELETE_ON_CLOSE so file is automatically deleted
	; but then need to have a way to also read the same temp file

	Invoke CreateFile, 'c:/test5.txt', GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL

	Cmp Eax, INVALID_HANDLE_VALUE
		Jne >.OK_35
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'CreateFile failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Invoke InternetCloseHandle, [hInternet_2]
		Invoke InternetCloseHandle, [hInternet_3]
		Return (TRUE)

.OK_35

	Mov [hOut], Eax

.loop_readfile_4

	Invoke InternetReadFile, [hInternet_3], Addr internetBuffer, SizeOf internetBuffer, Addr nIn

	Cmp Eax, NULL
		Jne >.OK_36
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'InternetReadFile failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Invoke InternetCloseHandle, [hInternet_2]
		Invoke InternetCloseHandle, [hInternet_3]
		Invoke CloseHandle, [hOut]
		Return (TRUE)

.OK_36

	; if no bytes were returned this time, jump to final processing
	Mov Eax, [nIn]
	Cmp Eax, 0
		Je >>.done_readfile_4

	; write the current bytes to the temp file
	Invoke WriteFile, [hOut], Addr internetBuffer, [nIn], Addr nOut, NULL

	Mov Ebx, [nIn]	; nIn, nOut are more traditional
	Cmp Ebx, [nOut]
		Je .loop_readfile_4 ; if write operation was OK, do it again
		; error processing
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'WriteFile failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Invoke InternetCloseHandle, [hInternet_2]
		Invoke InternetCloseHandle, [hInternet_3]
		Invoke CloseHandle, [hOut]
		Return (TRUE)

	; END OF LOOP

.done_readfile_4

	; file is on disk, internet operation complete
	Invoke InternetCloseHandle, [hInternet_1]
	Invoke InternetCloseHandle, [hInternet_2]
	Invoke InternetCloseHandle, [hInternet_3]
	Invoke CloseHandle, [hOut]

	Return (TRUE)
	; END of 5TH VERSION!!!
	;
	;
	;

	; testing internet access, 4th attempt
	; POST access to file
	; writing data directly to (temp) file
	; this version skips the file step = create filemap and display
	; DUMB MISTAKE: while building this I was testing along the way, but I didn't close the open handles at the end of the test,
	; DUMB MISTAKE: so I was getting some odd Internet errors, e.g. 12002 = ERROR_INTERNET_TIMEOUT

	Invoke InternetOpen, Addr userAgent, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0

Cmp Eax, NULL
		Jne >.OK_21
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'InternetOpen failed, error code from GetLastError', MB_ICONINFORMATION
		Return (TRUE)

.OK_21

	Mov [hInternet_1], Eax

	Invoke InternetConnect, [hInternet_1], Addr url_5, INTERNET_DEFAULT_HTTP_PORT, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 1
	; perhaps last value could be NULL instead of 1?

Cmp Eax, NULL
		Jne >.OK_22
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'InternetConnect failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Return (TRUE)

.OK_22

	Mov [hInternet_2], Eax

	Invoke HttpOpenRequest, [hInternet_2], "POST", Addr objectName, NULL, NULL, Addr acceptTypes, 0, 1

	Cmp Eax, NULL
		Jne >.OK_23
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'HttpOpenRequest xxx failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Invoke InternetCloseHandle, [hInternet_2]
		Return (TRUE)

.OK_23

	Mov [hInternet_3], Eax

	Invoke HttpSendRequest, [hInternet_3], Addr hdrs, SizeOf hdrs - 1, Addr frmdata, SizeOf frmdata - 1

	Cmp Eax, TRUE	; different return codes here!
		Je >.OK_24
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'HttpSendRequest failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Invoke InternetCloseHandle, [hInternet_2]
		Invoke InternetCloseHandle, [hInternet_3]
		Return (TRUE)

.OK_24

	; open a temporary file to save the data
	; could use FILE_FLAG_DELETE_ON_CLOSE so file is automatically deleted
	; but then need to have a way to also read the same temp file

	Invoke CreateFile, 'c:/test4.txt', GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL

	Cmp Eax, INVALID_HANDLE_VALUE
		Jne >.OK_25
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'CreateFile failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Invoke InternetCloseHandle, [hInternet_2]
		Invoke InternetCloseHandle, [hInternet_3]
		Return (TRUE)

.OK_25

	Mov [hOut], Eax

.loop_readfile_3

	Invoke InternetReadFile, [hInternet_3], Addr internetBuffer, SizeOf internetBuffer, Addr nIn

	Cmp Eax, NULL
		Jne >.OK_26
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'InternetReadFile failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Invoke InternetCloseHandle, [hInternet_2]
		Invoke InternetCloseHandle, [hInternet_3]
		Invoke CloseHandle, [hOut]
		Return (TRUE)

.OK_26

	; if no bytes were returned this time, jump to final processing
	Mov Eax, [nIn]
	Cmp Eax, 0
		Je >>.done_readfile_3

	; write the current bytes to the temp file
	Invoke WriteFile, [hOut], Addr internetBuffer, [nIn], Addr nOut, NULL

	Mov Ebx, [nIn]	; nIn, nOut are more traditional
	Cmp Ebx, [nOut]
		Je .loop_readfile_3 ; if write operation was OK, do it again
		; error processing
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'WriteFile failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Invoke InternetCloseHandle, [hInternet_2]
		Invoke InternetCloseHandle, [hInternet_3]
		Invoke CloseHandle, [hOut]
		Return (TRUE)

	; END OF LOOP

.done_readfile_3

	; file is on disk, internet operation complete
	Invoke InternetCloseHandle, [hInternet_1]
	Invoke InternetCloseHandle, [hInternet_2]
	Invoke InternetCloseHandle, [hInternet_3]
	Invoke CloseHandle, [hOut]

	Return (TRUE)
	; END of 4TH VERSION!!!
	;
	;
	;

	; testing internet access, 3rd attempt
	; writing data directly to (temp) file
	; then create filemap and display

	Invoke InternetOpen, Addr userAgent, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0

Cmp Eax, NULL
		Jne >.OK_6
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'InternetOpen failed, error code from GetLastError', MB_ICONINFORMATION
		Return (TRUE)

.OK_6

	Mov [hInternet_1], Eax

	Invoke InternetOpenUrl, [hInternet_1], Addr url_3, NULL, NULL, NULL, NULL

	Cmp Eax, NULL
		Jne >.OK_7
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'InternetOpenUrl failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Return (TRUE)

.OK_7

	Mov [hInternet_2], Eax

	; open a temporary file to save the data
	; could use FILE_FLAG_DELETE_ON_CLOSE so file is automatically deleted
	; but then need to have a way to also read the same temp file

	Invoke CreateFile, 'c:/test3.txt', GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL

	Cmp Eax, INVALID_HANDLE_VALUE
		Jne >.OK_8
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'CreateFile failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Invoke InternetCloseHandle, [hInternet_2]
		Return (TRUE)

.OK_8

	Mov [hOut], Eax

.loop_readfile_2

	Invoke InternetReadFile, [hInternet_2], Addr internetBuffer, SizeOf internetBuffer, Addr nIn

	Cmp Eax, NULL
		Jne >.OK_9
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'InternetReadFile failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Invoke InternetCloseHandle, [hInternet_2]
		Invoke CloseHandle, [hOut]
		Return (TRUE)

.OK_9

	; if no bytes were returned this time, jump to final processing
	Mov Eax, [nIn]
	Cmp Eax, 0
		Je >.done_readfile_2

	; write the current bytes to the temp file
	Invoke WriteFile, [hOut], Addr internetBuffer, [nIn], Addr nOut, NULL

	Mov Ebx, [nIn]	; nIn, nOut are more traditional
	Cmp Ebx, [nOut]
		Je .loop_readfile_2 ; if write operation was OK, do it again
		; error processing
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'WriteFile failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Invoke InternetCloseHandle, [hInternet_2]
		Invoke CloseHandle, [hOut]
		Return (TRUE)

	; END OF LOOP

.done_readfile_2

	; file is on disk, internet operation complete
	Invoke InternetCloseHandle, [hInternet_1]
	Invoke InternetCloseHandle, [hInternet_2]
	Invoke CloseHandle, [hOut]

	; open file for reading
	Invoke CreateFile, 'c:/test3.txt', GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL

	Cmp Eax, INVALID_HANDLE_VALUE
	Jne >.OK_10
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'CreateFile (2) failed, error code from GetLastError', MB_ICONINFORMATION
		Return (TRUE)

.OK_10

	Mov [hFile], Eax

	; check file length for fun
	Invoke GetFileSizeEx, [hFile], Addr fileSize

	Invoke CreateFileMapping, [hFile], NULL, PAGE_READONLY, 0, 0, NULL

	Cmp Eax, NULL
	Jne >.OK_11
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'CreateFileMapping failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke CloseHandle, [hFile]
		Return (TRUE)

.OK_11

	Mov [hFileMap], Eax

	Invoke MapViewOfFile, [hFileMap], FILE_MAP_READ, 0, 0, 0

	Cmp Eax, NULL
	Jne >.OK_12
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'MapViewOfFile failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke CloseHandle, [hFileMap]
		Invoke CloseHandle, [hFile]
		Return (TRUE)

.OK_12

	Mov [pMemory], Eax

	; display
	Invoke SetDlgItemText, [hWnd], IDC_WINMAIN_EDIT1, [pMemory]

	; close handles
	Invoke UnmapViewOfFile, [pMemory]
	Invoke CloseHandle, [hFileMap]
	Invoke CloseHandle, [hFile]

	Return (TRUE)
	; END of 3RD VERSION!!!
	;
	;
	;


	; testing internet access, 2nd attempt
	; works, now test with some UTF-8 and see what happens

	Invoke InternetOpen, Addr userAgent, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0

Cmp Eax, NULL
		Jne >.OK_3
		; need error processing here like below
		Invoke MessageBoxA, [hWnd], 'Failed to initialize http session 1', 'Message box test', MB_ICONINFORMATION
		Return (TRUE)

.OK_3

	Mov [hInternet_1], Eax

	Invoke InternetOpenUrl, [hInternet_1], Addr url_1, NULL, NULL, NULL, NULL

	Cmp Eax, NULL
		Jne >.OK_4
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'InternetOpenUrl failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		;Invoke MessageBoxA, [hWnd], 'Failed to initialize http session 2', 'Message box test', MB_ICONINFORMATION
		Return (TRUE)

.OK_4

	Mov [hInternet_2], Eax

.loop_readfile

	; get some bytes from remote file
	Invoke InternetReadFile, [hInternet_2], Addr internetBuffer_1, SizeOf internetBuffer_1 - 1, Addr numberOfBytesRead
	; DUMB MISTAKE: InternetReadFile seems to return more bytes than requested, overwriting after its buffer!

	Cmp Eax, NULL
		Jne >.OK_5
		Invoke GetLastError
		Invoke String, Eax, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'InternetReadFile failed, error code from GetLastError', MB_ICONINFORMATION
		Invoke InternetCloseHandle, [hInternet_1]
		Invoke InternetCloseHandle, [hInternet_2]
		Return (TRUE)

.OK_5

	; if no bytes were returned this time, jump to final processing
	Mov Eax, [numberOfBytesRead]
	Cmp Eax, 0
		Je >.done_readfile

	; add a zero to end of the new string and append to existing string
	Mov Edx, Addr internetBuffer_1
	Add Edx, [numberOfBytesRead]
	Mov D[Edx], 0H

	Invoke lszCat, Addr internetBuffer_2, Addr internetBuffer_1

	Jmp .loop_readfile
	; END OF LOOP

.done_readfile

	Invoke SetDlgItemText, [hWnd], IDC_WINMAIN_EDIT1, Addr internetBuffer_2

	; close handles

.close_2

	Invoke InternetCloseHandle, [hInternet_2]

.close_1

	Invoke InternetCloseHandle, [hInternet_1]

	Return (TRUE)

	; BAD BAD BAD CODE
	; testing internet access
	; this didn't work, see "WinHTTP vs. WinINet"
	;

	Invoke WinHttpOpen, Addr userAgent, WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0
	; needed to link "Winhttp.dll" and add include file "Winhttp.h"; this info available in MS website

	Cmp Eax, NULL
		Jne >.OK_1
		Invoke MessageBoxA, [hWnd], 'Failed to initialize http session 1', 'Message box test', MB_ICONINFORMATION

.OK_1

	Mov [hInternet], Eax
	; HINTERNET hConnected = WinHttpConnect(hInternet, L"www.askyb.com", INTERNET_DEFAULT_HTTP_PORT, 0);

	Invoke WinHttpConnect, [hInternet], Addr url_1, INTERNET_DEFAULT_HTTP_PORT, 0

	Cmp Eax, NULL
		Jne >.OK_2
		Invoke GetLastError
		Invoke WinHttpCloseHandle, [hInternet]
		Invoke MessageBoxA, [hWnd], 'Failed to initialize http session 2', 'Message box test', MB_ICONINFORMATION
		; error 2EE5 = 12005 = ERROR_INTERNET_INVALID_URL = "The URL is invalid."

.OK_2

	; END of BAD BAD BAD VERSION

	Return (TRUE)

	; testing new version of factorization function
	Mov Eax, 284
	Invoke getNumberOfFactors_v3

	Return (TRUE)

	; test of new sqrt function
	Mov Eax, 120
	Invoke getSqrtDD, Eax

	Return (TRUE)

	; test of Donkey's string library

	Invoke CreateArray, 100
	Mov [pArray], Eax

	Invoke AddString, [pArray], 'test'

	Invoke GetTopIndex, [pArray]

	Invoke GetString, [pArray], 1

	Invoke lszCat, Addr string1, Addr string2

	Return (TRUE)

	; test of GetOpenFileName

	Push SizeOf ofn
	Pop [ofn.lStructSize]
	Push [hWnd]
	Pop [ofn.hwndOwner]
	Push NULL
	Pop [ofn.hInstance]

	Mov [ofn.lpstrFilter], Addr filterString
	Mov [ofn.lpstrFile], Addr buffer
 	Mov D[ofn.nMaxFile], MAXSIZE

	Invoke GetOpenFileName, Addr ofn

.AAA_breakpoint_8

	Invoke MessageBoxA, [hWnd], [ofn.lpstrFile], 'Project Euler', MB_ICONINFORMATION

	Return (TRUE)

	; test of file open
	Invoke CreateFile, 'c:/test3.txt', GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL

	; test of file read
	Invoke CreateFile, 'c:/test3.txt', GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL

	Mov [hFile], Eax

	Cmp Eax, INVALID_HANDLE_VALUE
	Jnz >.fileOpenOK
		Invoke MessageBoxA, [hWnd], 'Error opening file', 'Project Euler', MB_ICONINFORMATION
		Return (TRUE)

.fileOpenOK

	Invoke ReadFile, [hFile], Addr fileBuffer, 10, Addr numberOfBytesRead, NULL

.AAA_breakpoint_9
	Invoke CloseHandle, Eax

.AAA_breakpoint_10

	Return (TRUE)

	; test of number to ascii conversion

	; clear myStringVar2 where ASCII number will be saved
	Mov Al, 0
	Lea Edi, Addr myStringVar2
	Mov Ecx, 100H
	Cld ; Clear destination flag, Std would do opposite
	Rep Stosb
	
	Mov Ecx, 1 ; digit counter
	Mov Ebx, 10
	Mov Eax, 2F0H ; number to convert to ASCII

.stringConversionLoop1:

	Xor Edx, Edx ; Edx = 0
	Div Ebx	; divide Edx:Eax by 10; quotient in Eax, remainder in Edx
	Push Edx ; push one digit
	Inc Ecx
	Cmp Eax, 9
	Ja .stringConversionLoop1

	Push Eax ; final digit

	Lea Edi, Addr myStringVar2

.stringConversionLoop2:
	; note: direction flag already clear
	Pop Eax
	Add Eax, 30H
	; Ecx already contains digit counter
	Stosb
	Loop .stringConversionLoop2

	Invoke SetDlgItemText, [hWnd], IDC_WINMAIN_EDIT1, Addr myStringVar2

; end of ASCII conversion test

	; testing STOSB
	; this code fills myStringVar2 with 0Ch
	Mov Al, 0CH
	Lea Edi, Addr myStringVar2
	Mov Ecx, 100H
	Cld ; Clear destination flag, Std would do opposite
	Rep Stosb

.AAA_breakpoint_7

	; testing MOVSB
	; this code copies myStringVar2 to myStringVar3
	Lea Esi, Addr myStringVar2
	Lea Edi, Addr myStringVar3
	Mov Ecx, 100H
	Cld ; Clear destination flag, Std would do opposite
	Rep Movsb

	; Division of long numbers

	Mov Eax, 0F12345BFH
	Mov [bigNumber2 + 4], Eax
	Mov [bigNumber2], Eax

	Mov Ebx, 177   					; Divisor = 10 (alternative: 177)

	Mov Edx, 0
	Mov Eax, [bigNumber2 + 4]		; Edx:Eax = number to divide = 12345BFD12345BFDh (alternative: F12345BFF12345BFH)
	Div Ebx
	Mov [bigNumber2 + 4], Eax

	Mov Eax, [bigNumber2]
	Div Ebx
	Mov [bigNumber2], Eax			; Edx holds remainder from division
									; Result = 1D20932E8386F99h (alternative: 015C C3A5 F73C F1EE)

	Return (TRUE)




	; System time test
	Invoke GetSystemTime, Addr time1
	Mov Eax, [time1.wSecond]
	And Eax, 000FFH						; AND required because time1.wSecond only has 16 bits (WORD)
	Invoke String, Eax, Addr clientTime, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr clientTime, 'system time test', MB_ICONINFORMATION

	Return (TRUE)




	; floating point test
	Mov Eax, 10000
	Mov [sqrtTest], Eax

	; load sqrtTest into ST0, take sqrt, save ST0 back to sqrtTest
	Fild D[sqrtTest]
	Fsqrt
	Fist D[sqrtTest]

	Invoke String, [sqrtTest], Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'sqrt test', MB_ICONINFORMATION

	Return (TRUE)




	; Test of FOREACH loop
	Mov Ecx, 10
	Mov Ebx, Addr intArray

.forEachLoop:

	Mov Eax, [Ebx + 4 * Ecx - 4]

	Push Eax
	Push Ebx
	Push Ecx
	Push Edx

	Invoke String, Eax, Addr myStringVar, ecHexa
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Array test', MB_ICONINFORMATION

	Pop Edx
	Pop Ecx
	Pop Ebx
	Pop Eax

	Loop .forEachLoop

	; Test of displaying a number in message window
	Mov Eax, 0F1234123H
	Invoke String, Eax, Addr myStringVar, ecHexa
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Message box test', MB_ICONINFORMATION

	; Try a division with modulo
	Mov Edx, 0					; clear dividend, high
	Mov Eax, 81					; dividend, low
	Mov Ecx, 3H					; divisor
	Div Ecx						; Eax = quotient, Edx = remainder

	; Test moving register value to variable and back
	Mov [myDD1], Eax
	Mov [myDD2], Edx

	Mov Eax, [myDD1]
	Invoke String, Eax, Addr myStringVar, ecHexa
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Project Euler + Quotient', MB_ICONINFORMATION

	Mov Edx, [myDD2]
	Cmp Edx, 0
		Jnz >.notModulo3

	Invoke String, Edx, Addr myStringVar, ecHexa
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Project Euler + Remainder is Modulo!', MB_YESNO

	; Process return value from message box
	Cmp Ax, IDYES
		Jnz >.notOK

.OK:
	Invoke MessageBoxA, [hWnd], 'You clicked yes!', 'Message box test', MB_OK
	Return (TRUE)

.notOK:
	Invoke MessageBoxA, [hWnd], 'I guess you clicked no!', 'Message box test', MB_OK
	Return (TRUE)

.notModulo3:

	Invoke String, Edx, Addr myStringVar, ecHexa
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Project Euler + Remainder is NOT Modulo!', MB_YESNO

	Return (TRUE)

; ************************************************************************************
.chkbtn24:						; Previous button not clicked, check button 5

	Cmp Ax, IDC_WINMAIN_BTN5		; Is this button 5?
		Jnz >>.chkButton7

	; This IS button 5 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Button 3 AND left click so process
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem 7, version 2', 'Project Euler', MB_OK

	; save time1
	Invoke GetSystemTime, Addr time1

	; EULER problem 7, version 2
	; Initialize variables
	; Store 2 and 3 in knownPrimes array
	Mov Eax, 2						; first prime = 2
	Mov Ebx, Addr knownPrimes		; Ebx = ptr to knownPrimes[0]
	Mov [Ebx], Eax					; knownPrimes[0] = 2
	Add Ebx, 4						; increment Ebx = ptr to knownPrimes[1]
	Mov Eax, 3						; second prime = 3
	Mov [Ebx], Eax					; knownPrimes[0] = 3

	; Initialise other variables here (in case routine is re-executed)
	; First candidate to check = 5
	Mov Eax, 5
	Mov [candidate], Eax

	; Two primes already known (= 2, 3)
	Mov Eax, 2
	Mov [primeCount], Eax

	; Number of primes to calculate
	; Why not just use primeLimit? Is it modified somewhere? Eliminated in version 3.
	;Mov Eax, [primeLimitConstant]		; normally 10001
	;Mov [primeLimit1], Eax

	; Iteration analysis: count number of iterations in secondary loop
	Mov Eax, 0
	Mov [iterCounter2], Eax

	; Prepare FPU
	Fstcw W[fpu_controlword_1]	;get the current Control Word to retain all setting bits
                 				;not related to the rounding control (RC) bits
	Fwait						;to insure the storage instruction is completed
	Mov Ax, [fpu_controlword_1]
;	And Ax, 0F3FFH 				;clears only the RC bits, leaving all other bits unchanged
								;not necessary here because both bits will be set
	Or Ax, 0C00H  				;this will set both bits of the RC field to the truncating mode
                  				;without affecting any of the other field's bits
    Mov [fpu_controlword_2], Ax	; store the modified Control Word in memory
    Fldcw W[fpu_controlword_2] 	;load the modified Control Word
	; Remember to restore control word at end of routine --> Fldcw W[fpu_controlword_1]

.mainLoopStart_2:

	; Take square root of candidate since we only need to test primes up to sqrt(candidate)
	; Floating point operations: load candidate into ST0, take sqrt, save ST0 back to candidateSquareRoot
	; (DUMB THING YOU DID: used Fist instead of Fistp, I think stack has to be popped or otherwise gets corrupted)
	Fild D[candidate]
	Fsqrt
	Fistp D[candidateSquareRoot]

	; primeFlag = TRUE
	Mov Eax, TRUE
	Mov [primeFlag], Eax

	; Ecx = loop counter
	Mov Ecx, 1

	; For analysis purposes, count number of iterations in secondary loop
	Mov Eax, 0
	Mov [iterCounter1], Eax

.secondaryLoop_2:

		; Iteration analysis
		Mov Eax, [iterCounter1]
		Inc Eax
		Mov [iterCounter1], Eax

		; load current prime to test
		Mov Ebx, Addr knownPrimes
		Mov Eax, [Ebx + 4 * Ecx]					; Ebx = 1, Eax = 3

		; if current prime > candidateSquareRoot, we're done (candidate is prime)
		Cmp Eax, [candidateSquareRoot]
		Ja >>.testDone_2

		Push Ecx					; Ecx holds loop counter but needed here for division

		; Limit not yet reached so test this prime
		; Divide candidate by current prime of interest
		Mov Edx, 0					; clear dividend, high
		Mov Ecx, Eax				; divisor = current prime we are checking
		Mov Eax, [candidate]		; dividend, low
		Div Ecx						; Eax = quotient, Edx = remainder

		Pop Ecx						; Reload loop counter

		; see if candidate/current prime = modulo 0 (--> not prime)
		Cmp Edx, 0
		Jnz >.secondaryLoopEnd_2
			; primeFlag = FALSE
			Mov Eax, FALSE
			Mov [primeFlag], Eax
			Jmp >.testDone_2

.secondaryLoopEnd_2:

	; Increment counter and loop back
	Inc Ecx
	Jmp .secondaryLoop_2

.testDone_2:

	; Iteration analysis (add secondary loop counter to main loop counter)
	Mov Eax, [iterCounter1]
	Add Eax, [iterCounter2]
	Mov [iterCounter2], Eax

	; Get primeCount in Ecx for final processing
	Mov Ecx, [primeCount]

	; IF primeFlag = TRUE THEN add new prime to array
	Mov Eax, [primeFlag]
	Cmp Eax, TRUE
	Jnz >.mainLoopEnd_2
		Mov Eax, [candidate]
		Mov Ebx, Addr knownPrimes
		Mov [Ebx + 4 * Ecx], Eax			; save new prime at end of knownPrimes array
		Add Ecx, 1							; primeCount += 1
		Mov [primeCount], Ecx

.mainLoopEnd_2:

	; candidate += 2 (next odd number)
	Mov Eax, [candidate]
	Add Eax, 2
	Mov [candidate], Eax

	; Compare primeCount and primeLimit1, loop back if primeCount < primeLimit1
	Mov Eax, [primeLimit1]
	Cmp Ecx, Eax
	Jnz .mainLoopStart_2

.finalProcessing_2

	; save time2
	Push Ecx
	Invoke GetSystemTime, Addr time2
	Pop Ecx

	; Display final result (nth prime, n = primeCount)
	; (Ecx = primeCount)
	Mov Ebx, Addr knownPrimes
	Mov Eax, [Ebx + 4 * Ecx - 4]

	Invoke String, Eax, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'version 2: nth prime (answer = 104743)', MB_ICONINFORMATION

	; process time difference
	Invoke SystemTimeToFileTime, Addr time1, Addr timeFT1
	Invoke SystemTimeToFileTime, Addr time2, Addr timeFT2

	Mov Eax, [timeFT1.dwLowDateTime]
	Mov Ebx, [timeFT2.dwLowDateTime]
	Sub Ebx, Eax		; time difference is x 100 ns (1E-7)

	; Divide result to get ms
	Mov Edx, 0					; clear dividend, high
	Mov Eax, Ebx				; dividend, low
	Mov Ecx, 10000					; divisor
	Div Ecx						; Eax = quotient, Edx = remainder

	Invoke String, Eax, Addr clientTime, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr clientTime, 'time diff in ms', MB_ICONINFORMATION

	; display analysis result
	Mov Eax, [iterCounter2]
	Invoke String, Eax, Addr clientTime, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr clientTime, 'iterations', MB_ICONINFORMATION

	; restore original FPU Control Word
    Fldcw W[fpu_controlword_1]

	Return (TRUE)

; ************************************************************************************
.chkButton7:						; Previous button not clicked, check button 7

	Cmp Ax, IDC_WINMAIN_BTN7		; Is this button 7?
		Jnz >>.chkButton8

	; This IS button 7 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem 3
	; remember the term SANITY CHECK???
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem 3, 32-bit...', 'Project Euler', MB_OK	; Project Euler Problem 3

	; Set value to test
	Mov Eax, 999999 				; (factors = 3 3 3 7 11 13 37)
	Mov Eax, 10005784 				; (factors = 2, 2, 2, 107, 11689)
	Mov Eax, 338BH  				; (= 13195d --> factors = 5, 7, 13 and 29)
	Mov Eax, 4H  					;
	Mov [numberToFactor], Eax		; low-order 32 bits

.AAA_Breakpoint_5

	; Get array of primes, first define primeLimit2 (need enough primes and big enough array!)
	;Mov Eax, 160001
	;Mov [primeLimit2], Eax			; primeLimit2 = 16001
	Invoke getPrimesArray, Addr knownPrimes, [primeLimit1]

.AAA_Breakpoint_4

	Invoke getPrimeFactors, Addr knownPrimes, Addr primeFactorArray, Addr numberToFactor
	; knownPrimes = array of known primes (DD array) (input value)
	; primeFactorArray = array of prime factors (output value)
	; numberToFactor = pointer to number to factor (input value)

	; DUMB MISTAKE: forgot the comma after "Invoke getPrimeFactors" and lost a day
	; trying to understand why the address of knownPrimes was not pushed onto stack

	;Invoke String, Eax, Addr myStringVar, ecDecimal
	;Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Problem 3: Eax value', MB_ICONINFORMATION

	Mov Ebx, Addr primeFactorArray
	Mov Eax, [Ebx]

.problem3DisplayLoop

	Push Eax
	Push Ebx

	Invoke String, Eax, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Problem 3: One factor', MB_ICONINFORMATION

	Pop Ebx
	Pop Eax

	Add Ebx, 4
	Mov Eax, [Ebx]
	Cmp Eax, 0
		Jnz .problem3DisplayLoop


.problem3End

	Return (TRUE)

; ************************************************************************************
.chkButton8:						; Previous button not clicked, check button 8

	Cmp Ax, IDC_WINMAIN_BTN8		; Is this button 8?
		Jnz >>.chkButton9

	; This IS button 8 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem 3 - 64-bit version
	; remember the term SANITY CHECK???
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem 3, 64-bit...', 'Project Euler', MB_OK	; Project Euler Problem 3

	; Set value to test (problem 3: 600851475143d = 8BE589EAC7h)
	;Mov Eax, 999999 				; (factors = 3 3 3 7 11 13 37)
	;Mov Eax, 10005784 				; (factors = 2, 2, 2, 107, 11689)
	;Mov Eax, 15
	;Mov Eax, 338BH  				; (= 13195d --> factors = 5, 7, 13 and 29)
	Mov Eax, 8BH					; value to factor = 600851475143d = 8B E589EAC7h
	Mov [numberToFactor_64 + 4], Eax	; high-order 32 bits
	Mov Eax, 0E589EAC7H
	Mov [numberToFactor_64], Eax		; low-order 32 bits

.problem3b_Breakpoint_5

	; Get array of primes, first define primeLimit2 (need enough primes and big enough array!)
	;Mov Eax, 160001
	;Mov [primeLimit2], Eax			; primeLimit2 = 16001
	Invoke getPrimesArray, Addr knownPrimes, [primeLimit1]

.problem3b_Breakpoint_4

	Invoke getPrimeFactors_v2, Addr knownPrimes, Addr primeFactorArray, Addr numberToFactor_64
	; knownPrimes = array of known primes (DD array) (input value)
	; primeFactorArray = array of prime factors (output value)
	; numberToFactor_64 = pointer to number to factor (input value)

	; DUMB MISTAKE: forgot the comma after "Invoke getPrimeFactors_v2" and lost a day
	; trying to understand why the address of knownPrimes was not pushed onto stack

	;Invoke String, Eax, Addr myStringVar, ecDecimal
	;Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Problem 3: Eax value', MB_ICONINFORMATION

	Mov Ebx, Addr primeFactorArray
	Mov Eax, [Ebx]

.problem3b_DisplayLoop

	Push Eax
	Push Ebx

	Invoke String, Eax, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Problem 3: One factor', MB_ICONINFORMATION

	Pop Ebx
	Pop Eax

	Add Ebx, 4
	Mov Eax, [Ebx]
	Cmp Eax, 0
		Jnz .problem3b_DisplayLoop


.problem3b_End

	Return (TRUE)

; ************************************************************************************
.chkButton9:						; Previous button not clicked, check button 9

	Cmp Ax, IDC_WINMAIN_BTN9		; Is this button 9?
		Jnz >>.chkbtn120

	; This IS button 9 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem 5
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem 5...', 'Project Euler', MB_OK

	; Eax = candidate
	Mov Eax, 21

.mainLoopProblem5

	Mov Ecx, 20

	.secondaryLoopProblem5

		Cmp Ecx, 1
		Jz >.foundAnswerProblem5

		Push Eax
		Push Ecx
		
		; Divide candidate by current factor 
		; (dividend = Edx:Eax, divisor = Ecx, quotient = Eax, remainder = Edx)
		Xor Edx, Edx				; 0:Eax = dividend			
		Div Ecx						; Eax = quotient, Edx = remainder
		
		Pop Ecx
		Pop Eax
		
		Cmp Edx, 0
		Jz >.secondaryLoopFinalProcessingProblem5
			Add Eax, 1
			Jmp .mainLoopProblem5
			
	.secondaryLoopFinalProcessingProblem5
	
		Loop .secondaryLoopProblem5
		
.foundAnswerProblem5

	Invoke String, Eax, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Problem 5: Answer (answer = 232792560)', MB_ICONINFORMATION

	Return (TRUE)

; ************************************************************************************
.chkbtn120:						; Previous button not clicked, check button 10

	Cmp Ax, IDC_WINMAIN_BTN10		; Is this button 10?
		Jnz >>.chkbtn121

	; This IS button 10 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem 5
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem 9...', 'Project Euler', MB_OK

	; Build array of integers up to 10E+6 with integral square root (ISR) = csq[i]
	Mov Ecx, 1
	Mov Ebx, Addr arrayOfSquares

	.loop1Problem9

		Mov Eax, Ecx
		Mul Ecx
		Mov [Ebx], Eax
		Add Ebx, 4
		Add Ecx, 1
		Cmp Ecx, 1001
			Jnz .loop1Problem9

	; test and see if value is there
	;Mov Eax, 999
	;Mov Ebx, Addr arrayOfSquares
	;Mov Edx, [Ebx + 4 * Eax]

	; Prepare FPU
	Fstcw W[fpu_controlword_1]	;get the current Control Word to retain all setting bits
                 				;not related to the rounding control (RC) bits
	Fwait						;to insure the storage instruction is completed
	Mov Ax, [fpu_controlword_1]
;	And Ax, 0F3FFH 				;clears only the RC bits, leaving all other bits unchanged
								;not necessary here because both bits will be set
	Or Ax, 0C00H  				;this will set both bits of the RC field to the truncating mode
                  				;without affecting any of the other field's bits
    Mov [fpu_controlword_2], Ax	; store the modified Control Word in memory
    Fldcw W[fpu_controlword_2] 	;load the modified Control Word
	; Remember to restore control word at end of routine --> Fldcw W[fpu_controlword_1]



	; Pythagorean triplet
	; csq = asq + bsq
	; asq = csq - bsq

	; Ebx = pointer to arrayOfSquares
	Mov Ebx, Addr arrayOfSquares							; Ebx = pointer to arrayOfSquares

	; i = 999
	Mov Ecx, 999											; Ecx = outer loop counter

	.loop2OuterProblem9

	Mov Edx, 0												; Edx = inner loop counter

		.loop2InnerProblem9

		Mov Eax, [Ebx + 4 * Ecx]							; Eax = csq

		; asq = csq - bsq
		Sub Eax, [Ebx + 4 * Edx]							; Eax = asq
		Jz >>.finalProcessingInnerLoopProblem9
		Jg >.notNegativeProblem9
			; negative number so continue with outer loop
			Loop .loop2OuterProblem9

		.notNegativeProblem9
		; check whether asq has an integer square root
		Mov [asq], Eax										; using asq as temp holder for value
		Fild D[asq]											; since Fild needs to load from memory (?)
		Fsqrt
		Fistp D[asq]
		Mov Eax, [asq]										; Eax = a
		Mov [a], Eax										; copy value to variable a

		Push Ecx
		Push Edx
		Mov Ecx, Eax
		Mul Ecx												; Eax = asq
		Pop Edx
		Pop Ecx

		; Eax now holds asq candidate
		Mov [asq], Eax
		Add Eax, [Ebx + 4 * Edx]								; asq + bsq
		Cmp Eax, [Ebx + 4 * Ecx]
			Jnz >>.finalProcessingInnerLoopProblem9

		.problem9Debug

		; found triplet
		Push Ecx
		Push Edx
		Mov Eax, [asq]											; asq
		; output
		Mov Eax, [Ebx + 4 * Edx]								; bsq
		; output
		Mov Eax, [Ebx + 4 * Ecx]								; csq
		; output
		Pop Edx
		Pop Ecx
	
		;is a + b + c = 1000?
		Mov Eax, [a]
		Add Eax, Ecx
		Add Eax, 1
		Add Eax, Edx
		Add Eax, 1
		Cmp Eax, 1000
			Jnz >.finalProcessingInnerLoopProblem9

			Push Ecx
			Push Edx

			Mov Eax, [a]
			Invoke String, Eax, Addr myStringVar, ecDecimal
			Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Problem 9: Answer 1', MB_ICONINFORMATION

			Pop Edx
			Mov Eax, Edx
			Add Eax, 1
			Invoke String, Eax, Addr myStringVar, ecDecimal
			Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Problem 9: Answer 2', MB_ICONINFORMATION

			Pop Ecx
			Mov Eax, Ecx
			Add Eax, 1
			Invoke String, Eax, Addr myStringVar, ecDecimal
			Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Problem 9: Answer 3', MB_ICONINFORMATION

			; End here or crash hard!
			Return (TRUE)
		
		.finalProcessingInnerLoopProblem9
		Add Edx, 1
		Cmp Edx, 1000
			Jnz .loop2InnerProblem9

		.finalProcessingOuterLoopProblem9
		;Loop .loop2OuterProblem9			; doesn't accept long jump
		Sub Ecx, 1
		Jmp <<.loop2OuterProblem9

	; restore original FPU Control Word
    Fldcw W[fpu_controlword_1]

	Return (TRUE)

; ************************************************************************************
.chkbtn121:						; Previous button not clicked, check button 11

	Cmp Ax, IDC_WINMAIN_BTN11		; Is this button 11?
		Jnz >>.chkbtn122

	; This IS button 11 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem 5
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem 6...', 'Project Euler', MB_OK

	; Initialize
	Mov Eax, 0
	Mov [sumOfSquares], Eax
	Mov [squareOfSum], Eax

	Mov Ecx, 100						; loop counter

	.loopProblem6

		; sumOfSquares += i*i
		Mov Eax, Ecx			; multiplicand in Eax
		Mul Ecx					; Ecx * Eax = Edx:Eax
		Cmp Edx, 0
		Jz >.noOverflow
			Invoke MessageBoxA, [hWnd], 'Overflow error in problem 6...', 'Project Euler', MB_OK

		.noOverflow
		Add [sumOfSquares], Eax

		; squareOfSum += i
		Add [squareOfSum], Ecx
		
		Loop .loopProblem6

	; squareOfSum = squareOfSum * squareOfSum
	Mov Eax, [squareOfSum]
	Mov Ecx, [squareOfSum]
	Mul Ecx
	Mov [squareOfSum], Eax

	; diff = squareOfSum - sumOfSquares
	Sub Eax, [sumOfSquares]

	Invoke String, Eax, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Problem 6: Answer (answer = xxx)', MB_ICONINFORMATION

	Return (TRUE)

; ************************************************************************************
.chkbtn122:						; Previous button not clicked, check button 12

	Cmp Ax, IDC_WINMAIN_BTN12		; Is this button 12?
		Jnz >>.chkbtn123

	; This IS button 12 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem 5
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem 8...', 'Project Euler', MB_OK

	Mov Ebx, Addr problem8DataBlock		; Ebx = pointer to start of problem8DataBlock

	.problem8OuterLoop

		.getFirstDigit
		Movzx Eax, B[Ebx]					; Eax = running product

		Cmp Al, 30H							; check if byte < 30H
		Jae >.greater30H_2
			Add Ebx, 1						; Increment Ebx pointer and skip irrelevant byte
			Jmp .getFirstDigit

		.greater30H_2
		Cmp Al, 39H							; check if byte > 39H
		Jbe >.isDigit_2
			Add Ebx, 1						; Increment Ebx pointer and skip irrelevant byte
			Jmp .getFirstDigit

		.isDigit_2
		Sub Al, 30H							; convert ASCII to integer

		Mov Esi, Ebx
		Add Esi, 1							; Esi now points to next byte to examine (2 of 5)

		Mov Ecx, 4							; Ecx = inner loop counter (multiply by next 4 numerical digits)

		.problem8InnerLoop

			Movzx Edx, B[Esi]					; Edx = next multiplicand

			; we want to skip any characters except "0", "1", "2", ..., "9"
			Cmp Dl, 30H
			Jae >.greater30H
				Add Esi, 1					; Increment Esi pointer and skip irrelevant byte
				Jmp .problem8InnerLoop

			.greater30H
			Cmp Dl, 39H
			Jbe >.isDigit
				Add Esi, 1					; Increment Esi pointer and skip irrelevant byte
				Jmp .problem8InnerLoop

			.isDigit
			Sub Dl, 30H
			Mul Edx							; Eax = Eax * Edx
			Add Esi, 1						; Increment Esi pointer
			Loop .problem8InnerLoop			; End of inner loop

		; see if current product of 5 numbers is > existing greatest product
		Cmp Eax, [problem8MaxProduct]
		Jbe >.notBigger
			Mov [problem8MaxProduct], Eax

		.notBigger
		Add Ebx, 1
		Cmp Ebx, Addr problem8MaxProduct - 4	; problem8MaxProduct is defined as next byte after data block
		Jb .problem8OuterLoop					; unsigned comparison (= Jl)

	Mov Eax, [problem8MaxProduct]
	Invoke String, Eax, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Problem 8 answer', MB_ICONINFORMATION

	Return (TRUE)


; ************************************************************************************
.chkbtn123:						; Previous button not clicked, check button 13

	Cmp Ax, IDC_WINMAIN_BTN13		; Is this button 13?
		Jnz >>.chkbtn124

	; This IS button 13 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem 5
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem 4...', 'Project Euler', MB_OK

	; Generate all products of a x b where a = 100 to 999 and b = 100 to 999 (a = 10 to 99 and b = 10 to 99)

	Mov Esi, 100						; counter 1

	.problem4OuterLoop

		Mov Edi, 100					; counter 2

		.problem4InnerLoop

			Mov Eax, Esi
			Mov Ecx, Edi
			Mul Ecx

			Mov Edx, Eax			; save copy of number in Edx

			; value to examine now in Eax = counter 1 x counter 2
			Invoke String, Eax, Addr myStringVar, ecDecimal

			Cmp Eax, 6
			Jnz >.not4DigitNumberOrPalindromeOrGreater

				.problem4Breakpoint1

				Movzx Eax, B[myStringVar]
				Movzx Ebx, B[myStringVar + 5]
				Cmp Eax, Ebx
				Jnz >.not4DigitNumberOrPalindromeOrGreater

					Movzx Eax, B[myStringVar + 1]
					Movzx Ebx, B[myStringVar + 4]
					Cmp Eax, Ebx
					Jnz >.not4DigitNumberOrPalindromeOrGreater

						Movzx Eax, B[myStringVar + 2]
						Movzx Ebx, B[myStringVar + 3]
						Cmp Eax, Ebx
						Jnz >.not4DigitNumberOrPalindromeOrGreater

							; we have found palindrome
							Cmp Edx, [maxPalindrome]
							Jb >.not4DigitNumberOrPalindromeOrGreater
								Mov [maxPalindrome], Edx

								.problem4Breakpoint2

			.not4DigitNumberOrPalindromeOrGreater
			Add Edi, 1
			Cmp Edi, 1000
			Jb .problem4InnerLoop
			
		; end of problem4InnerLoop

		Add Esi, 1
		Cmp Esi, 1000
		Jb .problem4OuterLoop

	; end of problem4OuterLoop

	Mov Eax, [maxPalindrome]

	Invoke String, Eax, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Problem 4 answer', MB_ICONINFORMATION

	Return (TRUE)

; ************************************************************************************
.chkbtn124:						; Previous button not clicked, check button 14

	Cmp Ax, IDC_WINMAIN_BTN14		; Is this button 14?
		Jnz >>.chkbtn125

	; This IS button 14 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem 5
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem 22...', 'Project Euler', MB_OK

	; test of file open
	;Invoke CreateFile, 'c:/test3.txt', GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL

	; test of file read
	Invoke CreateFile, 'c:\Documents and Settings\user\Desktop\names.txt', GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL
	Mov [hFile], Eax

	Cmp Eax, INVALID_HANDLE_VALUE
	Jnz >.fileOpenOKProb22
		Invoke MessageBoxA, [hWnd], 'Error opening file', 'Project Euler', MB_ICONINFORMATION
		Return (TRUE)

.fileOpenOKProb22

;.prob22_break_1
;.prob22_break_2
;.prob22_break_3

	; APPROACH 1 = preallocated memory (fileBuffer22)
	;Invoke ReadFile, [hFile], Addr fileBuffer22, 0B600H, Addr numberOfBytesRead, NULL
	;Invoke CloseHandle, [hFile]
	;Invoke SetDlgItemText, [hWnd], IDC_WINMAIN_EDIT1, Addr fileBuffer22

	; APPROACH 2 = GlobalAlloc (deprecated, use heap functions instead)
	;Invoke GlobalAlloc, GMEM_MOVEABLE Or GMEM_ZEROINIT, 0B601H
	;Mov [hMemory], Eax
	;Invoke GlobalLock, [hMemory]
	;Mov [pMemory], Eax

	; GlobalAlloc --> 0B601H, ReadFile --> 0B600H (extra NULL byte at end for end of string!)
	;Invoke ReadFile, [hFile], [pMemory], 0B600H, Addr numberOfBytesRead, NULL
	;Invoke CloseHandle, [hFile]

	;Invoke SetDlgItemText, [hWnd], IDC_WINMAIN_EDIT1, [pMemory]

	;Invoke GlobalUnlock, [pMemory]
	;Invoke GlobalFree, [hMemory]

	; APPROACH 3 = heap functions
	;Invoke HeapCreate, NULL, 0B601H, NULL
	;Mov [hHeap], Eax
	;Invoke HeapAlloc, [hHeap], HEAP_ZERO_MEMORY, 0B601H
	;Mov [pMemory], Eax

	;Invoke ReadFile, [hFile], [pMemory], 0B600H, Addr numberOfBytesRead, NULL
	;Invoke CloseHandle, [hFile]

	;Invoke SetDlgItemText, [hWnd], IDC_WINMAIN_EDIT1, [pMemory]

	;Invoke HeapFree, [hHeap], NULL, [pMemory]
	;Invoke HeapDestroy, [hHeap]

	; APPROACH 4 = file mapping
	Invoke CreateFileMapping, [hFile], NULL, PAGE_READONLY, 0, 0, NULL
	Mov [hFileMap], Eax

.prob22_break_2

	Invoke MapViewOfFile, [hFileMap], FILE_MAP_READ, 0, 0, 0
	Mov [pMemory], Eax

	Invoke GetFileSize, [hFile], NULL

	; create array
	Invoke CreateArray, 6000
	Mov [pArray], Eax

.prob22_break_1

	; start getting names from file
	Mov Esi, [pMemory]
	Mov Edi, Addr spareString
	Cld ; Clear destination flag, Std would do opposite
	Mov Ebx, TRUE	; Ebx = flag = first quote

.prob22_loop_1

	Mov Al, B[Esi]

	Cmp Al, 0	; end of file marker
		Je >.doneReadingFile

	Cmp Al, 2CH ; comma
		Jne >.notCommaOrZero
			; char IS comma
			Inc Esi
			Jmp .prob22_loop_1

	.notCommaOrZero
	Cmp Al, 22H	; is this character = double quote = "?
		Je >.isDoubleQuote
			; if we get here, char is LETTER DATA, so move it to string,
			; increment pointers and jump to top
			Movsb ; copy one byte
			Jmp .prob22_loop_1

	.isDoubleQuote ; first and second quotes have different processing
	Cmp Ebx, TRUE
		Jne >.secondQuote
			; this is first quote so increment Esi and jump to top
			Inc Esi
			Mov Ebx, FALSE	; Ebx = flag = second quote
			Jmp .prob22_loop_1

		.secondQuote
		; write zero to terminate string
		Mov B[Edi], 0
		Push Esi ; save current position in file
		; write string to string array
		Invoke AddString, [pArray], Addr spareString
		; reinitialize pointers
		Pop Esi
		Inc Esi
		Mov Edi, Addr spareString
		Mov Ebx, TRUE	; Ebx = flag = first quote
		Jmp .prob22_loop_1

.doneReadingFile

	; Invoke GetString, [pArray], 100

	Invoke SortArray, [pArray], TRUE, FALSE

	Invoke GetTopIndex, [pArray]

	Mov Ecx, Eax	; top index is loop counter
	Mov Ebx, 0		; initialize name score sum

L1:
	Invoke getProb22NameScore, [pArray], Ecx
	Add Ebx, Eax
	Loop L1

.prob22_break_3

	; display answer
	Invoke String, Ebx, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Problem 22 answer', MB_ICONINFORMATION

	Invoke SetDlgItemText, [hWnd], IDC_WINMAIN_EDIT1, [pMemory]

	Invoke UnmapViewOfFile, [pMemory]
	Invoke CloseHandle, [hFileMap]
	Invoke CloseHandle, [hFile]

	Return (TRUE)

; ************************************************************************************
.chkbtn125:						; Previous button not clicked, check button 15

	Cmp Ax, IDC_WINMAIN_BTN15		; Is this button 15?
		Jnz >>.chkbtn126

	; This IS button 15 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem xx1
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem 19...', 'Project Euler', MB_OK

	Mov Eax, 0
	Mov [sundaySum], Eax	; [sundaySum] = 0

	Mov Eax, 1901
	Mov [loopYear], Eax		; [loopYear] = 1901

.prob19_loop1

	Mov Eax, 1
	Mov [loopMonth], Eax

	.prob19_loop2

		Invoke getJulianDayNumber, [loopYear], [loopMonth], 1

		.prob19_break1

		; convert Julian Day Number to day of week (0 = Monday, etc.)
		Mov Edx, 0
		; Mov Eax, [jdn]
		Mov Ecx, 7
		Div Ecx

		; compare remainder from division with 6 = Sunday
		Cmp Edx, 6
		Jnz >.notSunday
			Inc D[sundaySum]

		.notSunday

		Inc D[loopMonth]
		Cmp D[loopMonth], 13
			Jnz .prob19_loop2

	Inc D[loopYear]
	Cmp D[loopYear], 2001
		Jnz .prob19_loop1

	Invoke String, [sundaySum], Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Problem 19 answer', MB_ICONINFORMATION

.prob19_break2

	Return (TRUE)

; ************************************************************************************
.chkbtn126:						; Previous button not clicked, check button 16

	Cmp Ax, IDC_WINMAIN_BTN16		; Is this button 16?
		Jnz >>.chkbtn127

	; This IS button 16 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem 20
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem 20...', 'Project Euler', MB_OK

.prob20_break1

	; initialize bigNum1 for test
	; 100! = 1B30964EC395DC24069528D54BBDA40D16E966EF9A70EB21B5B2943A321CDF10391745570CCA9420C6ECB3B72ED2EE8B02EA2735C61A000000000000000000000000H = 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000D
	; 40 works = 8EEAE81B84C7F27E080FDE64FF05254000000000H = 815915283247897734345611269596115894272000000000D
	; 30 works = 0D13F6370F96865DF5DD54000000H = 265252859812191058636308480000000D
	Mov Eax, 100						; Eax = n (n!)
	Mov [bigNum1], Eax
	Mov Ebx, Eax
	Sub Ebx, 1		            	; Ebx = multiplier = n - 1

.prob20_loop2

	Mov Ecx, 0						; loop counter
 	Mov [carryPart], Ecx            ; initialize carryPart = 0

.prob20_loop1

 	Mov Eax, [bigNum1 + 4 * Ecx]
 	Mul Ebx                			; Edx:Eax = Eax * Ebx
	Add Eax, [carryPart]   			; add carried part from previous mult
 	Mov [bigNum1 + 4 * Ecx], Eax	; save result
 	Mov [carryPart], Edx            ; save carried part

	Inc Ecx
	Cmp Ecx, 0100H
		Jnz .prob20_loop1

	Dec Ebx
	Cmp Ebx, 1
		Jnz .prob20_loop2

	; bigNum1 now contains factorial
	; need to convert to decimal value

	.prob20_break2

	Mov Eax, 30
	Mov [numDoubleWords], Eax			; numDoubleWords = 2

	Invoke getSumBigNumDigits, Addr bigNum1, Addr numDoubleWords

	Invoke String, Eax, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Problem 20 answer', MB_ICONINFORMATION

	Return (TRUE)

;
; this is the original code below BEFORE I put it into a function
;

.prob20_break3

	; initialize
	Mov Ebx, 10   						; divisor
	Mov Eax, 0
	Mov [digitCounter], Eax				; digitCounter = 0
	Mov Eax, 30
	Mov [numDoubleWords], Eax			; numDoubleWords = 0

.prob20_loop4

	Mov Ecx, [numDoubleWords]			; loop counter (number of double words in bigNum1)
 	Mov Edx, 0							; initialize Edx = 0

.prob20_loop3

 	Mov Eax, [bigNum1 + 4 * Ecx - 4]	; Edx:Eax = number to divide
 	Div Ebx								; Edx holds remainder from division
 	Mov [bigNum1 + 4 * Ecx - 4], Eax
	Loop .prob20_loop3

	Push Edx							; save one digit
	Inc D[digitCounter]

	; check whether done, i.e. Eax < 10 and all higher double words of bigNum1 = 0
	Cmp Eax, 9
	Ja .prob20_loop4

	; BEGIN check all higher double words of bigNum1 = 0
	; using Esi and Edi for this check
	Mov Esi, [numDoubleWords]			; loop counter (number of double words in bigNum1)
	Sub Esi, 1							; Esi = numDoubleWords - 1

	.prob20_loop_done_check
 	Mov Edi, [bigNum1 + 4 * Esi]
	Cmp Edi, 0
	Jne .prob20_loop4					; this DW in bigNum1 <> 0, so need to divide again
	Dec Esi
		Jnz .prob20_loop_done_check
	; END check all higher double words of bigNum1 = 0

	; push final digit and increment digitCounter
	Push Eax							; save last digit
	Inc D[digitCounter]

	; pop digits of stack and add
	Mov Eax, 0
	Mov Ecx, [digitCounter]

.prob20_loop5
	Pop Ebx
	Add Eax, Ebx
	Loop .prob20_loop5

	Invoke String, Eax, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Problem 20 answer', MB_ICONINFORMATION

	Return (TRUE)

; ************************************************************************************
.chkbtn127:						; Previous button not clicked, check button 17

	Cmp Ax, IDC_WINMAIN_BTN17		; Is this button 17?
		Jnz >>.chkbtn128

	; This IS button 17 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem 16
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem 16...', 'Project Euler', MB_OK

	Mov Eax, 2
	Mov [bigNum1], Eax
	Mov Ecx, 1000					; 2 to the N power (N = 15 or 1000)
	Sub Ecx, 1					; we actually need (N - 1)

.prob16_loop_1
	Mov Edx, 1					; Edx = counter for shifting into higher double words

	Shl D[bigNum1], 1
	PushF ;

	.prob16_loop_2
	PopF ; need to restore flags from last shift
	Rcl D[bigNum1 + 4 * Edx], 1
	PushF ; save flags to avoid conflict with loop counter
	Inc Edx
	Cmp Edx, 0FFH				; number of double words to use for calculation
		Jnz .prob16_loop_2

	PopF
	Loop .prob16_loop_1

.prob16_break_1

	Mov Eax, 0FFH
	Mov [numDoubleWords], Eax			; numDoubleWords = 2

	Invoke getSumBigNumDigits, Addr bigNum1, Addr numDoubleWords

	Invoke String, Eax, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Problem 16 answer', MB_ICONINFORMATION

	Return (TRUE)

; ************************************************************************************
.chkbtn128:						; Previous button not clicked, check button 18

	Cmp Ax, IDC_WINMAIN_BTN18		; Is this button 18?
		Jnz >>.chkbtn129

	; This IS button 18 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem xx1
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem 25...', 'Project Euler', MB_OK

	;Mov Eax, 0FFFFFFFFH
	;Mov [bigNum1], Eax
	;Mov [bigNum1 + 4], Eax

	Mov Eax, 03FFH
	Mov [numDoubleWords], Eax			; numDoubleWords = x

	Mov Eax, 1
	;Mov [n1], Eax
	;Mov [n2], Eax
	Mov [bigNum1], Eax
	Mov [bigNum2], Eax

	Mov Edx, 2							; term counter --> F2

.prob25_loop_1

	Inc Edx

	;Mov Eax, [n1]
	;Add Eax, [n2]	; Eax = n3 = n1 + n2
	;Mov Ebx, [n2]	; Ebx = copy of n2
	;Mov [n1], Ebx	; n1 = n2
	;Mov [n2], Eax	; n2 = n3
	;Mov [bigNum1], Eax

	Mov Eax, [bigNum1]
	Add Eax, [bigNum2]
	PushF
	Mov [bigNum3], Eax

	Mov Ecx, 1							; double word counter

	.prob25_loop_2

		PopF ; need to restore flags from last shift
		Mov Eax, [bigNum1 + 4 * Ecx]
		Adc Eax, [bigNum2 + 4 * Ecx]
		PushF ; save flags to avoid conflict with loop counter
		Mov [bigNum3 + 4 * Ecx], Eax

		Inc Ecx

		Cmp Ecx, [numDoubleWords]
		Jne .prob25_loop_2

	PopF ; last pop to clear

	; copy
	; n1 = n2
	Lea Esi, Addr bigNum2
	Lea Edi, Addr bigNum1
	Mov Ecx, [numDoubleWords]
	Cld ; Clear destination flag, Std would do opposite
	Rep Movsb

	; n2 = n3
	Lea Esi, Addr bigNum3
	Lea Edi, Addr bigNum2
	Mov Ecx, [numDoubleWords]
	Cld ; Clear destination flag, Std would do opposite
	Rep Movsb

	Push Edx
	Invoke getDecimalStringBigNum, Addr bigNum3, Addr numDoubleWords, Addr decimalString, Addr numDigits
	Pop Edx

.prob25_break_1

	Cmp Eax, 1000		; Eax = numDigits after function call
		Jnz .prob25_loop_1

	Invoke String, Edx, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Project Euler', MB_OK

	; final display of results
	Invoke SetDlgItemText, [hWnd], IDC_WINMAIN_EDIT1, Addr decimalString

	Invoke String, [numDigits], Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Project Euler', MB_OK

	Return (TRUE)

; ************************************************************************************
.chkbtn129:						; Previous button not clicked, check button 19

	Cmp Ax, IDC_WINMAIN_BTN19		; Is this button 19?
		Jnz >>.chkbtn130

	; This IS button 19 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem xx1
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem Problem 17...', 'Project Euler', MB_OK

/*
; DEBUG section
.prob17_loop_test
	Mov Eax, 115
	Invoke letterCounter
	Jmp .prob17_loop_test
*/
	; initialize
	Mov Ebx, 0		; sum
	Mov Ecx, 1000	; loop counter

	.prob17_loop
		Mov Eax, Ecx
		Invoke letterCounter	; FUNCTION INPUT = Eax = number to count, FUNCTION OUTPUT = Eax = number of letters
		Add Ebx, Eax
		Loop .prob17_loop

	Invoke String, Ebx, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Project Euler', MB_OK

	Return (TRUE)

; ************************************************************************************
.chkbtn130:						; Previous button not clicked, check button 20

	Cmp Ax, IDC_WINMAIN_BTN20		; Is this button 20
		Jnz >>.chkbtn131

	; This IS button 20 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem xx1
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem Problem 14...', 'Project Euler', MB_OK

	; initialize
	Mov Ebx, 0			; Ebx = maxChainLength
	Mov [maxStartingNumber], Ebx
	Mov Eax, 1			; Eax = startingNumber
	Mov [startingNumber], Eax

	.prob14_loop_2

		Mov Eax, [startingNumber]
		Mov Ecx, 1		; term counter

		.prob14_loop_1

			Invoke getProb14IterativeSequence

			Inc Ecx

			Cmp Eax, 1
			Jnz .prob14_loop_1

		Cmp Ecx, Ebx
		Jbe >.notGreater
			Mov Ebx, Ecx
			Mov Eax, [startingNumber]
			Mov [maxStartingNumber], Eax

		.notGreater

		Mov Eax, [startingNumber]
		Inc Eax
		Mov [startingNumber], Eax
		Cmp Eax, 1000000
		Jb .prob14_loop_2

		; display result
		Invoke String, [maxStartingNumber], Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Project Euler', MB_OK


	Return (TRUE)

; ************************************************************************************
.chkbtn131:						; Previous button not clicked, check button 21

	Cmp Ax, IDC_WINMAIN_BTN21		; Is this button 21
		Jnz >>.chkbtn132

	; This IS button 21 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem 11
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem Problem 11...', 'Project Euler', MB_OK

	; parse ascii data block into array of numbers

	Mov Esi, Addr problem11DataBlock
	Mov Edi, 0		; index into numberArray
	Xor Eax, Eax	; Eax = 0
	Mov Ebx, TRUE	; flag indicates processing of first digit
	Mov Ecx, 10		; multiplier = 10

.prob11_loop_1

	Cmp Esi, Addr problem11MaxProduct ; first byte after big data string
		Je >.prob11_parse_complete
	
	Mov Al, B[Esi]
	Cmp Al, 30H
		Jb >.prob11_finalProcessing
	Cmp Al, 39H
		Ja >.prob11_finalProcessing

	; if we get here, process a number
	Sub Eax, 30H	; convert ascii digit to number

	Cmp Ebx, TRUE
		Jne >.secondDigit
		; multiply this digit by 10
		Xor Edx, Edx	; Edx = 0
		Mul Ecx			; Eax = Eax = 10
		Mov Edx, Eax	; save number in Edx
		Mov Ebx, FALSE	; flag indicates processing of second digit
		Jmp >.prob11_finalProcessing

		.secondDigit
		Add Eax, Edx	; first digit x 10 + second digit
		Mov Ebx, TRUE	; flag indicates processing of second digit
		Mov [numberArray + 4 * Edi], Eax	; move decoded number to array
		Inc Edi

	.prob11_finalProcessing
	Inc Esi
	Jmp .prob11_loop_1

.prob11_parse_complete

	;
	; now we have all 200 numbers in numberArray
	;

	;
	; compute horizontal max (78 78 96 83 = row 8, col 10)
	;
	; result = 2E3B480h = 48477312

	Mov Edx, 0		; row = Edx
	Mov [numProductsChecked], Edx	; numProductsChecked = 0

	.prob11_loop_3_A	; rows = Edx (range = 0 to 19)

			; get row factor
			Mov Eax, Edx	; Eax = row
			Mov Ecx, 80		; 1 row = 20 * 4 bytes per number
			Push Edx 		; save Edx
			Mul Ecx			; Eax = row factor
			Mov [rowFactor], Eax

			Mov Edi, 0		; column = Edi

			.prob11_loop_4_A	; cols = Edi (range = 0 to 16)

				; get col factor
				Mov Eax, Edi	; Eax = col
				Mov Ecx, 4		; 1 col = 1 * 4 bytes per number
				Mul Ecx			; Eax = col factor
				Mov [colFactor], Eax

				Mov Ecx, 4
				Mov Esi, Addr numberArray
				Add Esi, [rowFactor]	; add row factor
				Add Esi, [colFactor]	; add col factor
				Mov Eax, [Esi + 4 * Ecx - 4]	; initialize product
				Dec Ecx

				.prob11_loop_2_A
					Mul D[Esi + 4 * Ecx - 4]	; multiply by one number
					Loop .prob11_loop_2_A

				Inc D[numProductsChecked]		; should equal 20 x 17 = 340 ?

				Cmp Eax, [problem11MaxProduct]
					Jb >.prob11_lessThan_A
					Mov [problem11MaxProduct], Eax
					Pop Eax						; pop row off stack
					Mov [maxRow1], Eax
					Push Eax					; save row again for later
					Mov [maxCol1], Edi

				.prob11_lessThan_A

				Inc Edi							; increment column
				Cmp Edi, 17
					Jb .prob11_loop_4_A

			Pop Edx								; restore Edx after multiply ops
			Inc Edx								; increment row
			Cmp Edx, 20
				Jb .prob11_loop_3_A

	;
	; compute vertical max (66 91 88 97 = row 6, col 15)
	;
	; result = 30E4690h = yyy

	Mov Edx, 0		; row = Edx
	Mov [numProductsChecked], Edx	; numProductsChecked = 0

	.prob11_loop_3_B	; rows = Edx (range = 0 to 16)

			; get row factor
			Mov Eax, Edx	; Eax = row
			Mov Ecx, 80		; 1 row = 20 * 4 bytes per number
			Push Edx 		; save Edx
			Mul Ecx			; Eax = row factor
			Mov [rowFactor], Eax

			Mov Edi, 0		; column = Edi

			.prob11_loop_4_B	; cols = Edi  (range = 0 to 19)

				; get col factor
				Mov Eax, Edi	; Eax = col
				Mov Ecx, 4		; 1 col = 1 * 4 bytes per number
				Mul Ecx			; Eax = col factor
				Mov [colFactor], Eax

				;Mov Ecx, 4
				Mov Esi, Addr numberArray
				Add Esi, [rowFactor]	; add row factor
				Add Esi, [colFactor]	; add col factor
				;
				;Mov Eax, [Esi + 80 * Ecx - 80]	; initialize product
				Add Esi, 240			; base address + 3 rows (80 * 3)
				Mov Eax, [Esi]
				;
				Mov Ecx, 3				; Ecx is loop counter for getting 3 remaining values

				.prob11_loop_2_B
					Sub Esi, 80			; base address + 160, 80, 0
					Mul D[Esi]			; multiply by one number
					Loop .prob11_loop_2_B

				Inc D[numProductsChecked]		; should equal 20 x 17 = 340 ?

				Cmp Eax, [problem11MaxProduct]
					Jb >.prob11_lessThan_B
					Mov [problem11MaxProduct], Eax
					Pop Eax						; pop row off stack
					Mov [maxRow1], Eax
					Push Eax					; save row again for later
					Mov [maxCol1], Edi

				.prob11_lessThan_B

				Inc Edi							; increment column
				Cmp Edi, 20
					Jb .prob11_loop_4_B

			Pop Edx								; restore Edx after multiply ops
			Inc Edx								; increment row
			Cmp Edx, 17
				Jb .prob11_loop_3_B

	;
	; compute LR diagonal max (sss = row xx, col xx)
	;
	; result = sss = yyy

	Mov Edx, 0		; row = Edx
	Mov [numProductsChecked], Edx	; numProductsChecked = 0

	.prob11_loop_3_C	; rows = Edx (range = 0 to 16)

			; get row factor
			Mov Eax, Edx	; Eax = row
			Mov Ecx, 80		; 1 row = 20 * 4 bytes per number
			Push Edx 		; save Edx
			Mul Ecx			; Eax = row factor
			Mov [rowFactor], Eax

			Mov Edi, 0		; column = Edi

			.prob11_loop_4_C	; cols = Edi  (range = 0 to 16)

				; get col factor
				Mov Eax, Edi	; Eax = col
				Mov Ecx, 4		; 1 col = 1 * 4 bytes per number
				Mul Ecx			; Eax = col factor
				Mov [colFactor], Eax

				;Mov Ecx, 4
				Mov Esi, Addr numberArray
				Add Esi, [rowFactor]	; add row factor
				Add Esi, [colFactor]	; add col factor
				;
				;Mov Eax, [Esi + 80 * Ecx - 80]	; initialize product
				Add Esi, 252			; base address + 3 rows (80 * 3)
				Mov Eax, [Esi]
				;
				Mov Ecx, 3				; Ecx is loop counter for getting 3 remaining values

				.prob11_loop_2_C
					Sub Esi, 84			; base address + 168, 84, 0
					Mul D[Esi]			; multiply by one number
					Loop .prob11_loop_2_C

				Inc D[numProductsChecked]		; should equal 17 x 17 = 289 ?

				Cmp Eax, [problem11MaxProduct]
					Jb >.prob11_lessThan_C
					Mov [problem11MaxProduct], Eax
					Pop Eax						; pop row off stack
					Mov [maxRow1], Eax
					Push Eax					; save row again for later
					Mov [maxCol1], Edi

				.prob11_lessThan_C

				Inc Edi							; increment column
				Cmp Edi, 17
					Jb .prob11_loop_4_C

			Pop Edx								; restore Edx after multiply ops
			Inc Edx								; increment row
			Cmp Edx, 17
				Jb .prob11_loop_3_C

	;
	; compute RL diagonal max (43547E2 = row 12, col 6)
	;
	; result = sss = yyy

	Mov Edx, 0		; row = Edx
	Mov [numProductsChecked], Edx	; numProductsChecked = 0

	.prob11_loop_3_D	; rows = Edx (range = 0 to 16)

			; get row factor
			Mov Eax, Edx	; Eax = row
			Mov Ecx, 80		; 1 row = 20 * 4 bytes per number
			Push Edx 		; save Edx
			Mul Ecx			; Eax = row factor
			Mov [rowFactor], Eax

			Mov Edi, 3		; column = Edi

			.prob11_loop_4_D	; cols = Edi  (range = 3 to 19)

				; get col factor
				Mov Eax, Edi	; Eax = col
				Mov Ecx, 4		; 1 col = 1 * 4 bytes per number
				Mul Ecx			; Eax = col factor
				Mov [colFactor], Eax

				;Mov Ecx, 4
				Mov Esi, Addr numberArray
				Add Esi, [rowFactor]	; add row factor
				Add Esi, [colFactor]	; add col factor
				;
				;Mov Eax, [Esi + 80 * Ecx - 80]	; initialize product
				Add Esi, 228			; base address + 3 rows (80 * 3)
				Mov Eax, [Esi]
				;
				Mov Ecx, 3				; Ecx is loop counter for getting 3 remaining values

				.prob11_loop_2_D
					Sub Esi, 76			; base address + 152, 76, 0
					Mul D[Esi]			; multiply by one number
					Loop .prob11_loop_2_D

				Inc D[numProductsChecked]		; should equal 17 x 17 = 289 ?

				Cmp Eax, [problem11MaxProduct]
					Jb >.prob11_lessThan_D
					Mov [problem11MaxProduct], Eax
					Pop Eax						; pop row off stack
					Mov [maxRow1], Eax
					Push Eax					; save row again for later
					Mov [maxCol1], Edi

				.prob11_lessThan_D

				Inc Edi							; increment column
				Cmp Edi, 20
					Jb .prob11_loop_4_D

			Pop Edx								; restore Edx after multiply ops
			Inc Edx								; increment row
			Cmp Edx, 17
				Jb .prob11_loop_3_D

.prob11_break_1

	; display result
	Invoke String, [problem11MaxProduct], Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Project Euler', MB_OK

	Return (TRUE)

; ************************************************************************************
.chkbtn132:						; Previous button not clicked, check button 22

	Cmp Ax, IDC_WINMAIN_BTN22		; Is this button 22
		Jnz >>.chkbtn133

	; This IS button 22 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem xx1
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem Problem 13...', 'Project Euler', MB_OK

	; REGISTER USAGE
	;
	; Esi = pointer to data block
	; Edi = multiplier = 10
	; Eax = holder for current char
	; Ebx = loop counter for mult operation
	; Ecx = 1. offset to current char 2. mult loop counter
	; 		3. main loop 4. loop to zero bigNum5
	;
	; VARIABLES
	;
	; bigNum4 = parsed 50-digit number
	; bigNum5 = spare used in parsing
	; bigNum6 = sum of 50-digit numbers
	; carryPart
	; problem13DataBlock
	; numDoubleWords
	; decimalString
	;

	; parse ascii number
	Mov Esi, Addr problem13DataBlock
	;Add Esi, 52	; get second number instead of first (relative offset = 52)
	Mov Ecx, 100		; main loop
	;Mov Ecx, 10			; main loop -- test ONLY x numbers

.prob13_loop_main

	Push Ecx

	; need to first clear all bytes of bigNum4
	Mov Eax, 0
	Push Edi
	Lea Edi, Addr bigNum4
	Mov Ecx, 40H
	Cld
	Rep Stosd
	Pop Edi
	; end of clear operation

	Mov Ecx, 49
	Xor Eax, Eax
	Mov Al, B[Esi + Ecx]
	Sub Eax, 30H
	Mov [bigNum4], Eax	; first digit now in bigNum4

	Mov Edi, 10	; multiplier

	.prob13_loop_1

		Mov Ebx, 50		; number of times to multiply by 10
		Sub Ebx, Ecx	; Ebx = 50 - Ecx (min. val of Ecx here = 1)

		Dec Ecx
		Push Ecx	; we must reuse Ecx as the next loop counter

		; need to first clear all bytes of bigNum5
		Mov Eax, 0
		Push Edi, Ecx
		Lea Edi, Addr bigNum5
		Mov Ecx, 40H
		Cld
		Rep Stosd
		Pop Ecx, Edi
		; end of clear operation

		; get next digit (Ecx = loop counter) and save in bigNum5
		Mov Al, B[Esi + Ecx]
		Sub Eax, 30H
		Mov [bigNum5], Eax

		; multiply bigNum5 by 10 ** Ebx (multiply digit x 10, Ebx times)
		.prob13_loop_3

			Mov Ecx, 0				; loop counter
	 		Mov [carryPart], Ecx	; initialize carryPart = 0

			.prob13_loop_2

				Mov Eax, [bigNum5 + 4 * Ecx]
				Mul Edi
				Add Eax, [carryPart]   			; add carried part from previous mult
			 	Mov [bigNum5 + 4 * Ecx], Eax	; save result
			 	Mov [carryPart], Edx            ; save carried part

				Inc Ecx
				Cmp Ecx, 040H
					Jnz .prob13_loop_2

			Dec Ebx
				Jnz .prob13_loop_3

		; add bigNum5 to bigNum4
		Mov Ecx, 0				; loop counter
		Clc ; clear carry flag for first addition
		PushF ; save flags

		.prob13_loop_4

			PopF ; restore flags
			Mov Eax, [bigNum5 + 4 * Ecx]
			Adc [bigNum4 + 4 * Ecx], Eax
			PushF ; save flags

			Inc Ecx
			Cmp Ecx, 040H
				Jnz .prob13_loop_4

		PopF ; final pop of flags to clear

		; pop Ecx and decrement
		Pop Ecx
		Cmp Ecx, 0
			Jg .prob13_loop_1


	;
	; parse complete for one 50-digit number
	;

	; add bigNum4 to bigNum6
	Mov Ecx, 0				; loop counter
	Clc ; clear carry flag for first addition
	PushF ; save flags

	.prob13_loop_5

		PopF ; restore flags
		Mov Eax, [bigNum4 + 4 * Ecx]
		Adc [bigNum6+ 4 * Ecx], Eax
		PushF ; save flags

		Inc Ecx
		Cmp Ecx, 040H
			Jnz .prob13_loop_5

	PopF ; final pop of flags to clear



	; increment and jumb back to process next big number
	Add Esi, 52			; 50 digits + 2 bytes for CR LF
	Pop Ecx
	Dec Ecx
	Jnz <<.prob13_loop_main

	; initialize for display routine
	Mov Eax, 40H
	Mov [numDoubleWords], Eax

	Invoke getDecimalStringBigNum, Addr bigNum6, Addr numDoubleWords, Addr decimalString, Addr numDigits
	Invoke SetDlgItemText, [hWnd], IDC_WINMAIN_EDIT1, Addr decimalString

.prob13_break_2

	Return (TRUE)

; ************************************************************************************
.chkbtn133:						; Previous button not clicked, check button 23

	Cmp Ax, IDC_WINMAIN_BTN23		; Is this button 23
		Jnz >>.chkbtn134

	; This IS button 23 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem xx1
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem Problem 12...', 'Project Euler', MB_OK

	; REGISTERS:
	;
	; Ebx = current triangle number
	; Ecx = i = number to test
	;
	; RESULTS: 200:2015
	;
	; NOTE: This is miserably slow. Needs a better factor-finding routine.
	; NOTE: Improved on 15dec12 with better routine: getNumberOfFactors_v3
	;

.prob12_break_1

	;Mov Eax, 385
	;Invoke getTriangleNumber

	Mov Ecx, 1
	;Mov Ecx, 561

.prob12_loop_1

	; skip debug message
	Jmp >.dontDisplayDebug

	; display Ecx for debugging
	Xor Edx, Edx
	Mov Eax, Ecx
	Mov Ebx, 2000	; division factor
	Div Ebx
	Cmp Edx, 0
		Jne >.dontDisplayDebug

		Push Ecx
		Invoke String, Ecx, Addr myStringVar, ecDecimal
		Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Project Euler - DEBUG', MB_OK
		;Invoke String, Ecx, Addr myStringVar, ecDecimal
		;Invoke SetDlgItemText, [hWnd], IDC_WINMAIN_EDIT1, Addr myStringVar
		Pop Ecx

.dontDisplayDebug

	;Cmp Ecx, 0FFFFFFFFH
	;Cmp Ecx, 0FH
		;Je >>.otherError

	; calculate triangle number
	;Mov Ecx, Edx
	;Mov Ebx, 0

	;.prob12_loop_2
		;Add Ebx, Ecx
		;Jc >>.carryError
		;Loop .prob12_loop_2
	; Ebx = triangle number

.prob12_break_2

	; compare with other calculation method
	Mov Eax, Ecx
	Invoke getTriangleNumber

	;Cmp Eax, Ebx
		;Jne >.wierdError

	; testing new version of factorization function
	;Invoke getNumberOfFactors_v2

.prob12_break_3

	Invoke getNumberOfFactors_v3
	Cmp Eax, 500
		Ja >.prob12_Done	; DUMB MISTAKE: (problem 12) was comparing for equality but needed greater than!

	Inc Ecx
		Jmp .prob12_loop_1

.prob12_Done

	; display result
	Mov Eax, Ecx
	Invoke getTriangleNumber

	Invoke String, Eax, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Project Euler - Problem 12 Result', MB_OK

	;Pop Ebx
	;Invoke String, Ebx, Addr myStringVar, ecDecimal
	;Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Project Euler', MB_OK

	Return (TRUE)

.wierdError

	Invoke String, Ecx, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Project Euler', MB_OK

	Return (TRUE)

.carryError

	PushA
	Invoke MessageBoxA, [hWnd], 'Big oops, a carry error occurred', 'Project Euler', MB_OK
	PopA

	Invoke String, Ecx, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Project Euler', MB_OK

	Return (TRUE)

.otherError
	Invoke MessageBoxA, [hWnd], 'Other error occurred', 'Project Euler', MB_OK

	Return (TRUE)

; ************************************************************************************
.chkbtn134:						; Previous button not clicked, check button 24

	Cmp Ax, IDC_WINMAIN_BTN24		; Is this button 24
		Jnz >>.chkbtn135

	; This IS button 24 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem 15
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem Problem 15...', 'Project Euler', MB_OK

	; Eax = row
	; Ebx = col
	; Ecx = grid size
	; Esi = arrival counter, low DW
	; Edi = arrival counter, high DW

	; wrong answer from evening 8dec12: 184B1B34h

.prob15_break_1

	; testing effect of INC on zero flag (it sets this flag but not carry flag)
	;Mov Eax, 0
	;Mov Esi, 0FFFFFFFFH
	;Inc Esi
	;Jnz >.prob15_test_1
	;	Inc Eax

.prob15_test_1

	Mov Eax, 0
	Mov Ebx, 0
	Mov Ecx, 20
	Mov Esi, 0
	Mov Edi, 0

	Invoke getProb15RecursiveFunction

	; display result
	Push Edi
	Invoke String, Esi, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Project Euler - Problem 15 (Esi)', MB_OK
	Pop Edi
	Invoke String, Edi, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Project Euler - Problem 15 (Edi)', MB_OK

	Return (TRUE)

; ************************************************************************************
.chkbtn135:						; Previous button not clicked, check button 25

	Cmp Ax, IDC_WINMAIN_BTN25		; Is this button 25
		Jnz >>.chkbtn136

	; This IS button 25 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem 18
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem Problem 18...', 'Project Euler', MB_OK

	Mov Esi, Addr problem18DataBlock
	Mov Edi, 0		; index into numberArray
	Xor Eax, Eax	; Eax = 0
	Mov Ebx, TRUE	; flag indicates processing of first digit
	Mov Ecx, 10		; multiplier = 10

.prob18_loop_1

	Cmp Esi, Addr triangleArray ; first byte after big data string
		Je >.prob18_parse_complete

	Mov Al, B[Esi]
	Cmp Al, 30H
		Jb >.prob18_finalProcessing
	Cmp Al, 39H
		Ja >.prob18_finalProcessing

	; if we get here, process a number
	Sub Eax, 30H	; convert ascii digit to number
	; single-digit version requires only the following 2 lines
	;Mov [triangleArray + Edi], Eax	; move decoded number to array
	;Inc Edi
	; end of single-digit version
	Cmp Ebx, TRUE
		Jne >.secondDigit_prob_18
		; multiply this digit by 10
		Xor Edx, Edx	; Edx = 0
		Mul Ecx			; Eax = Eax = 10
		Mov Edx, Eax	; save number in Edx
		Mov Ebx, FALSE	; flag indicates processing of second digit
		Jmp >.prob18_finalProcessing

		.secondDigit_prob_18
		Add Eax, Edx	; first digit x 10 + second digit
		Mov Ebx, TRUE	; flag indicates processing of second digit
		Mov [triangleArray + Edi], Eax	; move decoded number to array
		Inc Edi

	.prob18_finalProcessing
	Inc Esi
	Jmp .prob18_loop_1

.prob18_parse_complete

;
; build rowIndexArray for use in accessing row elements
;
	Mov Ecx, 100H

.prob18_loop_2
	Mov Eax, Ecx					; Eax = n
	Mov Ebx, Ecx
	Inc Ebx							; Ebx = n + 1
	Xor Edx, Edx
	Mul Ebx
	Shr Eax, 1						; Eax = n (n + 1) / 2
	Mov [rowIndexArray + 4 * Ecx], Eax
	Loop .prob18_loop_2

;
; rowIndexArray now complete!
;

	; some tests of getting numbers for specific row / col
	; get row 2, col 2
	Xor Edx, Edx
	Mov Eax, 2	; row
	Mov Eax, [rowIndexArray + 4 * Eax]
	Mov Ebx, 2	; col
	Mov Dl, B[triangleArray + Eax + Ebx]

	; get row 3, col 0
	Xor Edx, Edx
	Mov Eax, 3	; row
	Mov Eax, [rowIndexArray + 4 * Eax]
	Mov Ebx, 0	; col
	Mov Dl, B[triangleArray + Eax + Ebx]

	; get row 0, col 0
	Xor Edx, Edx
	Mov Eax, 0	; row
	Mov Eax, [rowIndexArray + 4 * Eax]
	Mov Ebx, 0	; col
	Mov Dl, B[triangleArray + Eax + Ebx]
	; end of tests

	; Eax = row
	; Ebx = col
	; Ecx = max row, e.g. 3, 14, 99
	; Edx = path counter
	; Esi = max sum of elements
	; Edi = current sum, also used to hold value of 4
	Mov Eax, 0	; row
	Mov Ebx, 0	; col
	Mov Ecx, 99
	Mov Edx, 0
	Mov Esi, 0
	Mov Edi, 0

	Invoke getProb18RecursiveFunction_v2, Addr triangleArray, Addr rowIndexArray
	; DUMB MISTAKE: changed name of function here but left old name elsewhere

.prob18_break_1

	; display result
	Invoke String, Esi, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Project Euler - Problem 18', MB_OK

	Return (TRUE)

; ************************************************************************************
.chkbtn136:						; Previous button not clicked, check button 26

	Cmp Ax, IDC_WINMAIN_BTN26		; Is this button 26
		Jnz >>.chkbtn137

	; This IS button 26 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem 21
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem Problem 21...', 'Project Euler', MB_OK

	;Mov Eax, 284
	;Invoke getSumOfProperDivisors

	; build array of sum of proper divisors of N (spdArray_
	Mov Ecx, 9999

.prob21_loop_1
	Mov Eax, Ecx
	Invoke getSumOfProperDivisors
	Mov [spdArray + 4 * Ecx], Eax
	Loop .prob21_loop_1

	; array now complete
	; check each value and see if d(a) = b and d(b) = a
	Mov Ecx, 9999	; Ecx = a
	Mov Edx, 0		; Edx = sum of amicable numbers
	Mov Esi, 0		; Esi = amicable number counter

.prob21_loop_2
	Mov Eax, [spdArray + 4 * Ecx]	; Eax = d(a) = b
	Mov Ebx, [spdArray + 4 * Eax]	; Ebx = d(b) = a ?
	Cmp Ebx, Ecx
		Jne >.notAmicableNumbers
		; still need to make sure that a <> b
		Cmp Ecx, Eax
		Je >.notAmicableNumbers
		; yes!
		Inc Esi
		Add Edx, Ecx	; only add a since b will be added separately
		; display interim result
		PushA
		;Invoke String, Ecx, Addr myStringVar, ecDecimal
		;Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Project Euler - Problem 21 partial result', MB_OK
		PopA

	.notAmicableNumbers
	Loop .prob21_loop_2

	; display result
	Invoke String, Edx, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Project Euler - Problem 21 final result', MB_OK

.prob21_break_1

	Return (TRUE)

; ************************************************************************************
.chkbtn137:						; Previous button not clicked, check button 27

	Cmp Ax, IDC_WINMAIN_BTN27		; Is this button 27
		Jnz >>.chkbtn138

	; This IS button 27 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem 23
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem Problem 23...', 'Project Euler', MB_OK
	; solved on 28dec12 = problem no 25 for me!

	; build array of abundant numbers < 28123
	Mov Ecx, 28123
	Mov Edx, 0		; index into array of abundant numbers
	;Mov Esi, 0		; Esi = abundant number counter
	Mov Edi, Addr spareString_2	; address of target string (needs sufficient memory allocation!)

.prob23_loop_1
	Mov Eax, Ecx
	Invoke getSumOfProperDivisors
	Cmp Eax, Ecx
		Jbe >.notAbundant
		; Inc Esi
		; Mov Ebx, Ecx 	; just for a temporary test to see lowest abundant number
		Mov [abundantNumArray + 4 * Edx], Ecx
		Inc Edx

		; check for odd numbers
		Test Ecx, 1
		Jz >.notAbundant ; don't display if even

		; compile numbers into a comma separated string
		Push Ecx, Edx, Esi
		; convert Ecx to string
		Invoke String, Ecx, Addr spareString_1, ecDecimal
		; append spareString to currentString --> new string in Edi
		Invoke lszCat, Edi, Addr spareString_1
		Invoke lszCat, Edi, ','	; append ',' to new string
		Mov Edi, Eax	; get new address of target string in Edi (not sure this is necessary)
		Pop Esi, Edx, Ecx

.notAbundant
	Loop .prob23_loop_1

	; now have array of abundant numbers
	; test all numbers <= 28123 and add to sum in Ebx if test positive
	Mov Ebx, 0	; sum
	Mov Ecx, 28123	; max number to test

.prob23_loop_2

	Invoke getProb23Function, Ecx, Addr spareString_1

	Cmp Eax, TRUE
		Je >.dontAdd
		Add Ebx, Ecx

.dontAdd
	Loop .prob23_loop_2

.prob23_break_1

	; display result
	;Push Edi
	Invoke String, Ebx, Addr myStringVar, ecDecimal
	;Pop Edi
	;Invoke SetDlgItemText, [hWnd], IDC_WINMAIN_EDIT1, Edi
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Project Euler - Problem 23', MB_OK

	Return (TRUE)

; ************************************************************************************
.chkbtn138:						; Previous button not clicked, check button 28

	Cmp Ax, IDC_WINMAIN_BTN28		; Is this button 28
		Jnz >>.chkbtn139

	; This IS button 28 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem xx1
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem Problem xx3...', 'Project Euler', MB_OK

	Return (TRUE)

; ************************************************************************************
.chkbtn139:						; Previous button not clicked, check button 29

	Cmp Ax, IDC_WINMAIN_BTN29		; Is this button 29
		Jnz >>.chkbtn140

	; This IS button 29 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem xx1
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem Problem xx4...', 'Project Euler', MB_OK

	Return (TRUE)

; ************************************************************************************
.chkbtn140:						; Previous button not clicked, check button 30

	Cmp Ax, IDC_WINMAIN_BTN30		; Is this button 30
		Jnz >>.chkbtn141

	; This IS button 30 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem xx1
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem Problem xx5...', 'Project Euler', MB_OK

	Return (TRUE)

; ************************************************************************************
.chkbtn141:						; Previous button not clicked, check button 31

	Cmp Ax, IDC_WINMAIN_BTN31		; Is this button 31
		Jnz >>.chkbtn25

	; This IS button 31 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

	; Project Euler Problem xx1
	Invoke MessageBoxA, [hWnd], 'Now calculating answer to problem Problem xx6...', 'Project Euler', MB_OK

	Return (TRUE)

; ************************************************************************************
.chkbtn25:						; Previous button not clicked, check button 6

	Cmp Ax, IDC_WINMAIN_BTN6		; Is this button 6?
		Jnz >>.exitProcedure

	; This IS button 6 so check for left click
	Shr Eax, 16
	Cmp Ax, BN_CLICKED
		Jnz >>.exitProcedure

.AAA_Breakpoint_2

	; Get array of primes, first define primeLimit2 (need enough primes and big enough array!)
	;Mov Eax, 160001
	;Mov [primeLimit2], Eax			; primeLimit2 = 16001

	Invoke getPrimesArray, Addr knownPrimes, [primeLimit2]

	; Display final result (nth prime, n = primeCount)
	; (Ecx = primeCount)
	Mov Ebx, Addr knownPrimes
	Mov Ecx, [primeLimit2]
	Mov Eax, [Ebx + 4 * Ecx - 4]

	Invoke String, Eax, Addr myStringVar, ecDecimal
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'version 3: nth prime (answer = xxx)', MB_ICONINFORMATION

	Mov Ebx, Addr knownPrimes
	Mov Ecx, 0						; loop counter
	Mov [bigNumber], Ecx			; initialize bigNumber, low order to 0
	Mov [bigNumber + 4], Ecx		; initialize bigNumber, high order to 0

.forLoopProblem10

	Mov Eax, [Ebx + 4 * Ecx]		; Eax = knownPrimes[i]
	Cmp Eax, 2000000
	Ja >.doneProblem10
		Add D[bigNumber], Eax
 		Adc D[bigNumber + 4], 0
		;Jc >.overflowHandler
		Add Ecx, 1
		Jmp .forLoopProblem10

.doneProblem10

	Invoke String, [bigNumber + 4], Addr myStringVar, ecHexa
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Problem 10 high-order result (answer = 21H)', MB_ICONINFORMATION
	Invoke String, [bigNumber], Addr myStringVar, ecHexa
	Invoke MessageBoxA, [hWnd], Addr myStringVar, 'Problem 10 low-order result (answer = 4653F83AH)', MB_ICONINFORMATION

	Return (TRUE)

; ************************************************************************************
.exitProcedure:					; None of checked buttons were clicked

	Return (FALSE)

; End OnwinMainClickBtn
EndU

winMainbtn1 Frame hWnd, uMsg, wParam, lParam
	Xor Eax, Eax	;Return (FALSE)
	Ret
EndF


